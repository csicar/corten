
@article{erdin_verication_nodate,
	title = {Veriﬁcation of Rust Generics, Typestates, and Traits},
	pages = {75},
	author = {Erdin, Matthias},
	langid = {english},
	file = {Erdin - Veriﬁcation of Rust Generics, Typestates, and Trai.pdf:/home/csicar/Zotero/storage/UIQXBPV7/Erdin - Veriﬁcation of Rust Generics, Typestates, and Trai.pdf:application/pdf},
}

@thesis{denis_creusot_2021,
	title = {The Creusot Environment for the Deductive Verification of Rust Programs},
	institution = {Inria Saclay-Île de France},
	type = {phdthesis},
	author = {Denis, Xavier and Jourdan, Jacques-Henri and Marché, Claude},
	date = {2021},
	file = {Full Text:/home/csicar/Zotero/storage/IQIUWIZQ/Denis et al. - 2021 - The Creusot Environment for the Deductive Verifica.pdf:application/pdf;Snapshot:/home/csicar/Zotero/storage/K7HUXUK5/hal-03526634.html:text/html},
}

@inproceedings{matsushita_rusthorn_2020,
	title = {{RustHorn}: {CHC}-based verification for Rust programs},
	shorttitle = {{RustHorn}},
	pages = {484--514},
	booktitle = {European Symposium on Programming},
	publisher = {Springer, Cham},
	author = {Matsushita, Yusuke and Tsukada, Takeshi and Kobayashi, Naoki},
	date = {2020},
	file = {Full Text:/home/csicar/Zotero/storage/IV87RRRX/Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:application/pdf;Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:/home/csicar/Zotero/storage/TW2TN794/Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:application/pdf},
}

@article{beckmann_verifying_2020,
	title = {Verifying Safe Clients of Unsafe Code and Trait Implementations in Rust},
	author = {Beckmann, Jakob},
	date = {2020},
	file = {Full Text:/home/csicar/Zotero/storage/7W24IZJG/Beckmann - 2020 - Verifying Safe Clients of Unsafe Code and Trait Im.pdf:application/pdf},
}

@article{reed_patina_2015,
	title = {Patina: A formalization of the Rust programming language},
	shorttitle = {Patina},
	pages = {264},
	journaltitle = {University of Washington, Department of Computer Science and Engineering, Tech. Rep. {UW}-{CSE}-15-03-02},
	author = {Reed, Eric},
	date = {2015},
	file = {Full Text:/home/csicar/Zotero/storage/5ZNMKC3P/Reed - 2015 - Patina A formalization of the Rust programming la.pdf:application/pdf},
}

@article{gordon_rely-guarantee_nodate,
	title = {Rely-Guarantee References for Reﬁnement Types Over Aliased Mutable Data (Extended Version ∗)},
	abstract = {Reasoning about side effects and aliasing is the heart of verifying imperative programs. Unrestricted side effects through one reference can invalidate assumptions about an alias. We present a new type system approach to reasoning about safe assumptions in the presence of aliasing and side effects, unifying ideas from reference immutability type systems and rely-guarantee program logics. Our approach, rely-guarantee references, treats multiple references to shared objects similarly to multiple threads in rely-guarantee program logics. We propose statically associating rely and guarantee conditions with individual references to shared objects. Multiple aliases to a given object may coexist only if the guarantee condition of each alias implies the rely condition for all other aliases. We demonstrate that existing reference immutability type systems are special cases of rely-guarantee references.},
	pages = {21},
	author = {Gordon, Colin S and Ernst, Michael D and Grossman, Dan},
	langid = {english},
	file = {Gordon et al. - Rely-Guarantee References for Reﬁnement Types Over.pdf:/home/csicar/Zotero/storage/8XFSDE5Z/Gordon et al. - Rely-Guarantee References for Reﬁnement Types Over.pdf:application/pdf},
}

@inproceedings{sato_combining_2019,
	location = {Cascais, Portugal},
	title = {Combining higher-order model checking with refinement type inference},
	isbn = {978-1-4503-6226-9},
	url = {http://dl.acm.org/citation.cfm?doid=3294032.3294081},
	doi = {10.1145/3294032.3294081},
	abstract = {There have been two major approaches to fully automated verification of higher-order functional programs: higherorder model checking and refinement type inference. The former approach is precise, but suffers from a bottleneck in the predicate discovery phase. The latter approach is generally faster than the former, thanks to the recent advances in constrained Horn clause ({CHC}) solving, but is imprecise, in that it rejects some valid programs. To take the best of the two approaches, we refine the higher-order model checking approach, by employing {CHC} solving in the predicate discovery phase. We have implemented the new approach and confirmed that the new system can verify more programs than those based on the previous two approaches.},
	eventtitle = {the 2019 {ACM} {SIGPLAN} Workshop},
	pages = {47--53},
	booktitle = {Proceedings of the 2019 {ACM} {SIGPLAN} Workshop on Partial Evaluation and Program Manipulation  - {PEPM} 2019},
	publisher = {{ACM} Press},
	author = {Sato, Ryosuke and Iwayama, Naoki and Kobayashi, Naoki},
	urldate = {2022-01-27},
	date = {2019},
	langid = {english},
	file = {Sato et al. - 2019 - Combining higher-order model checking with refinem.pdf:/home/csicar/Zotero/storage/23RTH8SA/Sato et al. - 2019 - Combining higher-order model checking with refinem.pdf:application/pdf},
}

@inproceedings{oconnor_refinement_2016,
	location = {Nara Japan},
	title = {Refinement through restraint: bringing down the cost of verification},
	isbn = {978-1-4503-4219-3},
	url = {https://dl.acm.org/doi/10.1145/2951913.2951940},
	doi = {10.1145/2951913.2951940},
	shorttitle = {Refinement through restraint},
	abstract = {We present a framework aimed at signiﬁcantly reducing the cost of verifying certain classes of systems software, such as ﬁle systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for eﬃcient C code generation; and one functional, suitable for equational reasoning and veriﬁcation. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C veriﬁcation frameworks.},
	eventtitle = {{ICFP}'16: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {89--102},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {O'Connor, Liam and Chen, Zilin and Rizkallah, Christine and Amani, Sidney and Lim, Japheth and Murray, Toby and Nagashima, Yutaka and Sewell, Thomas and Klein, Gerwin},
	urldate = {2022-01-27},
	date = {2016-09-04},
	langid = {english},
	file = {O'Connor et al. - 2016 - Refinement through restraint bringing down the co.pdf:/home/csicar/Zotero/storage/VGLKJBTZ/O'Connor et al. - 2016 - Refinement through restraint bringing down the co.pdf:application/pdf},
}

@article{weiss_oxide_2021,
	title = {Oxide: The Essence of Rust},
	url = {http://arxiv.org/abs/1903.00982},
	shorttitle = {Oxide},
	abstract = {Rust claims to advance industrial programming by bridging the gap between low-level systems programming and high-level application programming. At the heart of the argument that this enables programmers to build more reliable and efficient software is the borrow checker - a novel approach to ownership that aims to balance type system expressivity with usability. And yet, to date there is no core type system that captures Rust's notion of ownership and borrowing, and hence no foundation for research on Rust to build upon. In this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. We present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as an approximation of the provenances of references, and our type system is able to automatically compute this information through a substructural typing judgment. We provide the first syntactic proof of type safety for borrow checking using progress and preservation. Oxide is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.},
	journaltitle = {{arXiv}:1903.00982 [cs]},
	author = {Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Ahmed, Amal},
	urldate = {2022-01-27},
	date = {2021-10-19},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1903.00982},
	keywords = {Computer Science - Programming Languages},
	file = {Weiss et al. - 2021 - Oxide The Essence of Rust.pdf:/home/csicar/Zotero/storage/GEWQA5M8/Weiss et al. - 2021 - Oxide The Essence of Rust.pdf:application/pdf},
}

@article{kloos_asynchronous_2015,
	title = {Asynchronous Liquid Separation Types},
	url = {http://drops.dagstuhl.de/opus/volltexte/2015/5223/},
	doi = {10.4230/LIPICS.ECOOP.2015.396},
	abstract = {We present a reﬁnement type system for reasoning about asynchronous programs manipulating shared mutable state. Our type system guarantees the absence of races and the preservation of user-speciﬁed invariants using a combination of two ideas: reﬁnement types and concurrent separation logic. Our type system allows precise reasoning about programs using two ingredients. First, our types are indexed by sets of resource names and the type system tracks the eﬀect of program execution on individual heap locations and task handles. In particular, it allows making strong updates to the types of heap locations. Second, our types track ownership of shared state across concurrently posted tasks and allow reasoning about ownership transfer between tasks using permissions. We demonstrate through several examples that these two ingredients, on top of the framework of liquid types, are powerful enough to reason about correct behavior of practical, complex, asynchronous systems manipulating shared heap resources.},
	pages = {25 pages},
	author = {Kloos, Johannes and Majumdar, Rupak and Vafeiadis, Viktor},
	editora = {Herbstritt, Marc},
	editoratype = {collaborator},
	urldate = {2022-01-27},
	date = {2015},
	langid = {english},
	note = {Artwork Size: 25 pages
Medium: application/pdf
Publisher: Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik {GmbH}, Wadern/Saarbruecken, Germany},
	keywords = {000 Computer science, knowledge, general works, Computer Science},
	file = {Kloos et al. - 2015 - Asynchronous Liquid Separation Types.pdf:/home/csicar/Zotero/storage/WAE34UL7/Kloos et al. - 2015 - Asynchronous Liquid Separation Types.pdf:application/pdf},
}

@article{jung_rustbelt_2018,
	title = {{RustBelt}: securing the foundations of the Rust programming language},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3158154},
	doi = {10.1145/3158154},
	shorttitle = {{RustBelt}},
	abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
	pages = {1--34},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
	urldate = {2022-02-17},
	date = {2018-01},
	langid = {english},
	file = {Jung et al. - 2018 - RustBelt securing the foundations of the Rust pro.pdf:/home/csicar/Zotero/storage/8PK9HFSL/Jung et al. - 2018 - RustBelt securing the foundations of the Rust pro.pdf:application/pdf},
}

@article{lanzinger_property_nodate,
	title = {Property Types in Java: Combining Type Systems and Deductive Verification},
	pages = {136},
	author = {Lanzinger, Florian},
	langid = {english},
	file = {Lanzinger - Property Types in Java Combining Type Systems and.pdf:/home/csicar/Zotero/storage/XIEBH65B/Lanzinger - Property Types in Java Combining Type Systems and.pdf:application/pdf},
}

@thesis{lanzinger_property_2021,
	title = {Property Types in Java: Combining Type Systems and Deductive Verification},
	institution = {Karlsruher Institut für Technologie},
	type = {Master Thesis},
	author = {Lanzinger, Florian},
	date = {2021-02},
	file = {Lanzinger - Property Types in Java Combining Type Systems and.pdf:/home/csicar/Zotero/storage/BI3XCAJ6/Lanzinger - Property Types in Java Combining Type Systems and.pdf:application/pdf},
}

@article{lanzinger_property_nodate-1,
	title = {Property Types in Java: Combining Type Systems and Deductive Verification},
	pages = {136},
	author = {Lanzinger, Florian},
	langid = {english},
}

@article{astrauskas_how_2020,
	title = {How do programmers use unsafe rust?},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3428204},
	doi = {10.1145/3428204},
	abstract = {Rust’s ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that frequently occur in conventional imperative programs. However, the restrictions imposed by Rust’s type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g. doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as
              unsafe
              and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, an important assumption of the Rust language, which we dub the
              Rust hypothesis
              , is that programmers use Rust by following three main principles: use unsafe code sparingly, make it easy to review, and hide it behind a safe abstraction such that client code can be written in safe Rust.
            
            Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analysing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program’s source code, its intermediate representation {MIR}, as well as type information provided by the Rust compiler; we complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.},
	pages = {1--27},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Astrauskas, Vytautas and Matheja, Christoph and Poli, Federico and Müller, Peter and Summers, Alexander J.},
	urldate = {2022-02-23},
	date = {2020-11-13},
	langid = {english},
	file = {Astrauskas et al. - 2020 - How do programmers use unsafe rust.pdf:/home/csicar/Zotero/storage/TGABAAYT/Astrauskas et al. - 2020 - How do programmers use unsafe rust.pdf:application/pdf},
}

@article{astrauskas_leveraging_2019,
	title = {Leveraging rust types for modular specification and verification},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3360573},
	doi = {10.1145/3360573},
	abstract = {{CCS} Concepts: • General and reference → Verification; • Theory of computation → Programming logic; Separation logic; Program specifications; Program verification; • Software and its engineering → Software verification; Formal software verification.},
	pages = {1--30},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Astrauskas, Vytautas and Müller, Peter and Poli, Federico and Summers, Alexander J.},
	urldate = {2022-02-23},
	date = {2019-10-10},
	langid = {english},
	file = {Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:/home/csicar/Zotero/storage/TUIPHR3X/Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:application/pdf},
}

@article{breaux_2021_2021,
	title = {The 2021 software developer shortage is coming},
	volume = {64},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3440753},
	doi = {10.1145/3440753},
	abstract = {Companies must address the difficulty of hiring and retaining high-skilled employees from an increasingly smaller labor supply.},
	pages = {39--41},
	number = {7},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Breaux, Travis and Moritz, Jennifer},
	urldate = {2022-03-15},
	date = {2021-06-21},
	file = {Full Text PDF:/home/csicar/Zotero/storage/6FCF336Z/Breaux und Moritz - 2021 - The 2021 software developer shortage is coming.pdf:application/pdf},
}

@article{breaux_2021_2021-1,
	title = {The 2021 Software Developer Shortage is Coming},
	volume = {64},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3440753},
	doi = {10.1145/3440753},
	abstract = {Companies must address the difficulty of hiring and retaining high-skilled employees from an increasingly smaller labor supply.},
	pages = {39--41},
	number = {7},
	journaltitle = {Commun. {ACM}},
	author = {Breaux, Travis and Moritz, Jennifer},
	date = {2021-06},
	note = {Place: New York, {NY}, {USA}
Publisher: Association for Computing Machinery},
}

@article{graf_lower_2020,
	title = {Lower your guards: a compositional pattern-match coverage checker},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3408989},
	doi = {10.1145/3408989},
	shorttitle = {Lower your guards},
	abstract = {A compiler should warn if a function defined by pattern matching does not cover its inputs—that is, if there are missing or redundant patterns. Generating such warnings accurately is difficult for modern languages due to the myriad of language features that interact with pattern matching. This is especially true in Haskell, a language with a complicated pattern language that is made even more complex by extensions offered by the Glasgow Haskell Compiler ({GHC}). Although {GHC} has spent a significant amount of effort towards improving its pattern-match coverage warnings, there are still several cases where it reports inaccurate warnings.
            
              We introduce a coverage checking algorithm called Lower Your Guards, which boils down the complexities of pattern matching into
              guard trees
              . While the source language may have many exotic forms of patterns, guard trees only have three different constructs, which vastly simplifies the coverage checking process. Our algorithm is modular, allowing for new forms of source-language patterns to be handled with little changes to the overall structure of the algorithm. We have implemented the algorithm in {GHC} and demonstrate places where it performs better than {GHC}’s current coverage checker, both in accuracy and performance.},
	pages = {1--30},
	issue = {{ICFP}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Graf, Sebastian and Peyton Jones, Simon and Scott, Ryan G.},
	urldate = {2022-03-15},
	date = {2020-08-02},
	langid = {english},
	file = {Graf et al. - 2020 - Lower your guards a compositional pattern-match c.pdf:/home/csicar/Zotero/storage/LEFXNJPB/Graf et al. - 2020 - Lower your guards a compositional pattern-match c.pdf:application/pdf},
}

@inproceedings{vazou_abstract_2013,
	location = {Berlin, Heidelberg},
	title = {Abstract Refinement Types},
	isbn = {978-3-642-37036-6},
	doi = {10.1007/978-3-642-37036-6_13},
	abstract = {We present abstract refinement types which enable quantification over the refinements of data- and function-types. Our key insight is that we can avail of quantification while preserving {SMT}-based decidability, simply by encoding refinement parameters as uninterpreted propositions within the refinement logic. We illustrate how this mechanism yields a variety of sophisticated means for reasoning about programs, including: parametric refinements for reasoning with type classes, index-dependent refinements for reasoning about key-value maps, recursive refinements for reasoning about recursive data types, and inductive refinements for reasoning about higher-order traversal routines. We have implemented our approach in a refinement type checker for Haskell and present experiments using our tool to verify correctness invariants of various programs.},
	pages = {209--228},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Vazou, Niki and Rondon, Patrick M. and Jhala, Ranjit},
	editor = {Felleisen, Matthias and Gardner, Philippa},
	date = {2013},
	langid = {english},
	file = {Springer Full Text PDF:/home/csicar/Zotero/storage/88XPM8P7/Vazou et al. - 2013 - Abstract Refinement Types.pdf:application/pdf},
}

@inproceedings{foster_flow-sensitive_2002,
	location = {New York, {NY}, {USA}},
	title = {Flow-sensitive type qualifiers},
	isbn = {978-1-58113-463-6},
	url = {https://doi.org/10.1145/512529.512531},
	doi = {10.1145/512529.512531},
	series = {{PLDI} '02},
	abstract = {We present a system for extending standard type systems with flow-sensitive type qualifiers. Users annotate their programs with type qualifiers, and inference checks that the annotations are correct. In our system only the type qualifiers are modeled flow-sensitively---the underlying standard types are unchanged, which allows us to obtain an efficient constraint-based inference algorithm that integrates flow-insensitive alias analysis, effect inference, and ideas from linear type systems to support strong updates. We demonstrate the usefulness of flow-sensitive type qualifiers by finding a number of new locking bugs in the Linux kernel.},
	pages = {1--12},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2002 conference on Programming language design and implementation},
	publisher = {Association for Computing Machinery},
	author = {Foster, Jeffrey S. and Terauchi, Tachio and Aiken, Alex},
	urldate = {2022-03-21},
	date = {2002-05-17},
	keywords = {alias analysis, constraints, effect inference, flow-sensitivity, linux kernel, locking, restrict, type qualifiers, types},
	file = {Full Text PDF:/home/csicar/Zotero/storage/RD45TVBX/Foster et al. - 2002 - Flow-sensitive type qualifiers.pdf:application/pdf},
}

@collection{muller_programming_2020,
	title = {Programming Languages and Systems: 29th European Symposium on Programming, {ESOP} 2020, Held as Part of the European Joint Conferences on Theory and Practice of Software, {ETAPS} 2020, Dublin, Ireland, April 25–30, 2020, Proceedings},
	url = {https://library.oapen.org/handle/20.500.12657/37721},
	shorttitle = {Programming Languages and Systems},
	abstract = {This open access book constitutes the proceedings of the 29th European Symposium on Programming, {ESOP} 2020, which was planned to take place in Dublin, Ireland, in April 2020, as Part of the European Joint Conferences on Theory and Practice of Software, {ETAPS} 2020. The actual {ETAPS} 2020 meeting was postponed due to the Corona pandemic. The papers deal with fundamental issues in the specification, design, analysis, and implementation of programming languages and systems.},
	publisher = {Springer Nature},
	editor = {Müller, Peter},
	urldate = {2022-03-21},
	date = {2020},
	doi = {10.1007/978-3-030-44914-8},
	note = {Accepted: 2020-05-13T14:21:46Z},
	keywords = {Algorithms \& data structures, artificial intelligence, bic Book Industry Communication::U Computing \& information technology::{UM} Computer programming / software development::{UMB} Algorithms \& data structures, bic Book Industry Communication::U Computing \& information technology::{UM} Computer programming / software development::{UMX} Programming \& scripting languages: general, bic Book Industry Communication::U Computing \& information technology::{UT} Computer networking \& communications, bic Book Industry Communication::U Computing \& information technology::{UY} Computer science, bic Book Industry Communication::U Computing \& information technology::{UY} Computer science::{UYQ} Artificial intelligence::{UYQL} Natural language \& machine translation, Compilers, Compilers \& interpreters, Computer networking \& communications, computer networks, computer programming, Computer science, computer security, Computer Systems Organization and Communication Networks, Control Structures and Microprogramming, distributed computer systems, embedded systems, formal languages, formal logic, Information Systems and Communication Service, Interpreters, linguistics, Mathematical theory of computation, mathematics, model checking, Natural language \& machine translation, Natural Language Processing ({NLP}), object-oriented programming, parallel processing systems, program compilers, Programming \& scripting languages: general, Programming Languages, semantics, software architecture, software design, software engineering, software quality, Theory of Computation, verification and validation},
	file = {Full Text PDF:/home/csicar/Zotero/storage/U3CDRJXW/Müller - 2020 - Programming Languages and Systems 29th European S.pdf:application/pdf},
}

@online{noauthor_crossmark_nodate,
	title = {Crossmark},
	url = {https://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-44914-8_25&domain=pdf},
	urldate = {2022-03-21},
	file = {Crossmark:/home/csicar/Zotero/storage/Y3HLBDV2/dialog.html:text/html},
}

@inproceedings{toman_consort_2020,
	location = {Cham},
	title = {{ConSORT}: Context- and Flow-Sensitive Ownership Refinement Types for Imperative Programs},
	isbn = {978-3-030-44914-8},
	doi = {10.1007/978-3-030-44914-8_25},
	shorttitle = {{ConSORT}},
	abstract = {We present {ConSORT}, a type system for safety verification in the presence of mutability and aliasing. Mutability requires strong updates to model changing invariants during program execution, but aliasing between pointers makes it difficult to determine which invariants must be updated in response to mutation. Our type system addresses this difficulty with a novel combination of refinement types and fractional ownership types. Fractional ownership types provide flow-sensitive and precise aliasing information for reference variables. {ConSORT} interprets this ownership information to soundly handle strong updates of potentially aliased references. We have proved {ConSORT} sound and implemented a prototype, fully automated inference tool. We evaluated our tool and found it verifies non-trivial programs including data structure implementations.},
	pages = {684--714},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {Toman, John and Siqi, Ren and Suenaga, Kohei and Igarashi, Atsushi and Kobayashi, Naoki},
	editor = {Müller, Peter},
	date = {2020},
	langid = {english},
	file = {Springer Full Text PDF:/home/csicar/Zotero/storage/SV4MFYBL/Toman et al. - 2020 - ConSORT Context- and Flow-Sensitive Ownership Ref.pdf:application/pdf},
}

@article{ullrich_simple_2016,
	title = {Simple Veriﬁcation of Rust Programs via Functional Puriﬁcation},
	pages = {65},
	author = {Ullrich, Sebastian},
	date = {2016-12-06},
	langid = {english},
	file = {Ullrich - Simple Veriﬁcation of Rust Programs via Functional.pdf:/home/csicar/Zotero/storage/7M7KBPV4/Ullrich - Simple Veriﬁcation of Rust Programs via Functional.pdf:application/pdf},
}

@article{matsushita_rusthornbelt_2022,
	title = {{RustHornBelt}: A Semantic Foundation for Functional Verification of Rust Programs with Unsafe Code},
	abstract = {Rust is a systems programming language that offers both lowlevel memory operations and high-level safety guarantees, via a strong ownership type system that prohibits mutation of aliased state. In prior work, Matsushita et al. developed {RustHorn}, a promising technique for functional verification of Rust code: it leverages the strong invariants of Rust types to express the behavior of stateful Rust code with first-order logic ({FOL}) formulas, whose verification is amenable to offthe-shelf automated techniques. {RustHorn}’s key idea is to use prophecies to describe the behavior of mutable borrows. However, the soundness of {RustHorn} was only established for a safe subset of Rust, and it has remained unclear how to extend it to support various safe {APIs} that encapsulate unsafe code (i.e., code where Rust’s aliasing discipline is relaxed).},
	pages = {16},
	journaltitle = {San Diego},
	author = {Matsushita, Yusuke and Denis, Xavier and Jourdan, Jacques-Henri and Dreyer, Derek},
	date = {2022},
	langid = {english},
	file = {Matsushita et al. - 2022 - RustHornBelt A Semantic Foundation for Functional.pdf:/home/csicar/Zotero/storage/S38GFT6S/Matsushita et al. - 2022 - RustHornBelt A Semantic Foundation for Functional.pdf:application/pdf},
}

@book{pierce_types_2002,
	location = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	pagetotal = {623},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002},
	langid = {english},
	keywords = {Programming languages (Electronic computers)},
	file = {Pierce - 2002 - Types and programming languages.pdf:/home/csicar/Zotero/storage/JUQL6P2M/Pierce - 2002 - Types and programming languages.pdf:application/pdf},
}

@book{pierce_types_2002-1,
	location = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	pagetotal = {623},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002},
	langid = {english},
	keywords = {Programming languages (Electronic computers)},
	file = {Pierce - 2002 - Types and programming languages.pdf:/home/csicar/Zotero/storage/QPZQ4MSZ/Pierce - 2002 - Types and programming languages.pdf:application/pdf},
}

@inproceedings{rondon_liquid_2008,
	location = {Tucson, {AZ}, {USA}},
	title = {Liquid types},
	isbn = {978-1-59593-860-2},
	url = {http://portal.acm.org/citation.cfm?doid=1375581.1375602},
	doi = {10.1145/1375581.1375602},
	eventtitle = {the 2008 {ACM} {SIGPLAN} conference},
	pages = {159},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation  - {PLDI} '08},
	publisher = {{ACM} Press},
	author = {Rondon, Patrick M. and Kawaguci, Ming and Jhala, Ranjit},
	urldate = {2022-06-30},
	date = {2008},
	langid = {english},
	file = {liquid_types.pdf:/home/csicar/Zotero/storage/IQLHNHZT/liquid_types.pdf:application/pdf},
}

@article{fouilhe_revisiting_nodate,
	title = {Revisiting the abstract domain of polyhedra: constraints-only representation and formal proof},
	pages = {153},
	author = {Fouilhe, Alexis},
	langid = {english},
	file = {Fouilhe - Revisiting the abstract domain of polyhedra const.pdf:/home/csicar/Zotero/storage/NVK6MIUN/Fouilhe - Revisiting the abstract domain of polyhedra const.pdf:application/pdf},
}

@article{singh_fast_2017,
	title = {Fast polyhedra abstract domain},
	volume = {52},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/3093333.3009885},
	doi = {10.1145/3093333.3009885},
	abstract = {Numerical abstract domains are an important ingredient of modern static analyzers used for verifying critical program properties (e.g., absence of buffer overflow or memory safety). Among the many numerical domains introduced over the years, Polyhedra is the most expressive one, but also the most expensive: it has worst-case exponential space and time complexity. As a consequence, static analysis with the Polyhedra domain is thought to be impractical when applied to large scale, real world programs. In this paper, we present a new approach and a complete implementation for speeding up Polyhedra domain analysis. Our approach does not lose precision, and for many practical cases, is orders of magnitude faster than state-of-the-art solutions. The key insight underlying our work is that polyhedra arising during analysis can usually be kept decomposed, thus considerably reducing the overall complexity. We first present the theory underlying our approach, which identifies the interaction between partitions of variables and domain operators. Based on the theory we develop new algorithms for these operators that work with decomposed polyhedra. We implemented these algorithms using the same interface as existing libraries, thus enabling static analyzers to use our implementation with little effort. In our evaluation, we analyze large benchmarks from the popular software verification competition, including Linux device drivers with over 50K lines of code. Our experimental results demonstrate massive gains in both space and time: we show end-to-end speedups of two to five orders of magnitude compared to state-of-the-art Polyhedra implementations as well as significant memory gains, on all larger benchmarks. In fact, in many cases our analysis terminates in seconds where prior code runs out of memory or times out after 4 hours. We believe this work is an important step in making the Polyhedra abstract domain both feasible and practically usable for handling large, real-world programs.},
	pages = {46--59},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Singh, Gagandeep and Püschel, Markus and Vechev, Martin},
	urldate = {2022-07-13},
	date = {2017-01-01},
	keywords = {Abstract interpretation, Numerical program analysis, Partitions, Performance optimization, Polyhedra decomposition},
}

@article{singh_fast_nodate,
	title = {Fast Polyhedra Abstract Domain},
	abstract = {Numerical abstract domains are an important ingredient of modern static analyzers used for verifying critical program properties (e.g., absence of buffer overﬂow or memory safety). Among the many numerical domains introduced over the years, Polyhedra is the most expressive one, but also the most expensive: it has worst-case exponential space and time complexity. As a consequence, static analysis with the Polyhedra domain is thought to be impractical when applied to large scale, real world programs.},
	pages = {14},
	author = {Singh, Gagandeep and Püschel, Markus and Vechev, Martin},
	langid = {english},
	file = {Singh et al. - Fast Polyhedra Abstract Domain.pdf:/home/csicar/Zotero/storage/R548YWGI/Singh et al. - Fast Polyhedra Abstract Domain.pdf:application/pdf},
}

@article{puschel_fast_nodate,
	title = {Fast Polyhedra Abstract Domain},
	pages = {75},
	author = {Püschel, Gagandeep Singh Markus and Vechev, Martin},
	langid = {english},
	file = {Püschel und Vechev - Fast Polyhedra Abstract Domain.pdf:/home/csicar/Zotero/storage/PGPVADME/Püschel und Vechev - Fast Polyhedra Abstract Domain.pdf:application/pdf},
}

@incollection{ramalingam_sound_2008,
	location = {Berlin, Heidelberg},
	title = {A Sound Floating-Point Polyhedra Abstract Domain},
	volume = {5356},
	isbn = {978-3-540-89329-5 978-3-540-89330-1},
	url = {http://link.springer.com/10.1007/978-3-540-89330-1_2},
	abstract = {The polyhedra abstract domain is one of the most powerful and commonly used numerical abstract domains in the ﬁeld of static program analysis based on abstract interpretation. In this paper, we present an implementation of the polyhedra domain using ﬂoating-point arithmetic without sacriﬁcing soundness. Floating-point arithmetic allows a compact memory representation and an eﬃcient implementation on current hardware, at the cost of some loss of precision due to rounding. Our domain is based on a constraint-only representation and employs sound ﬂoating-point variants of Fourier-Motzkin elimination and linear programming. The preliminary experimental results of our prototype are encouraging. To our knowledge, this is the ﬁrst time that the polyhedra domain is adapted to ﬂoating-point arithmetic in a sound way.},
	pages = {3--18},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Chen, Liqian and Miné, Antoine and Cousot, Patrick},
	editor = {Ramalingam, G.},
	urldate = {2022-07-13},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-89330-1_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Chen et al. - 2008 - A Sound Floating-Point Polyhedra Abstract Domain.pdf:/home/csicar/Zotero/storage/VM5WRSYB/Chen et al. - 2008 - A Sound Floating-Point Polyhedra Abstract Domain.pdf:application/pdf},
}

@misc{lehmann_flux_2022,
	title = {Flux: Liquid Types for Rust},
	url = {http://arxiv.org/abs/2207.04034},
	shorttitle = {Flux},
	abstract = {Low-level pointer-manipulating programs are hard to verify, requiring complex spatial program logics that support reasoning about aliasing and separation. Worse, when working over collections, these logics burden the programmer with annotating loops with quantified invariants that describe the contents of the collection. We present Flux, which shows how logical refinements can work hand in glove with Rust's ownership mechanisms to yield ergonomic type-based verification for low-level imperative code. To do so Flux indexes mutable locations, with pure (immutable) values that can appear in the refinements, and then exploits Rust's ownership mechanisms to abstract sub-structural reasoning about locations within Rust's polymorphic type constructors, extended by a notion of strong references to idiomatically track strong updates. By factoring complex invariants into type constructors and simple refinements, Flux can efficiently synthesize loop annotations via liquid inference. We use a suite of vector-manipulating programs to demonstrate the advantages of Flux's refinement types over program logics, as implemented in the state-of-the-art Prusti verifier. We show that liquid typing makes verification ergonomic by slashing specification lines by a factor of two, verification time by an order of magnitude, and invariant annotation overhead from 14\% of code size, to nothing at all.},
	number = {{arXiv}:2207.04034},
	publisher = {{arXiv}},
	author = {Lehmann, Nico and Geller, Adam and Barthe, Gilles and Vazou, Niki and Jhala, Ranjit},
	urldate = {2022-07-14},
	date = {2022-07-08},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2207.04034 [cs]},
	note = {Number: {arXiv}:2207.04034},
	keywords = {Computer Science - Programming Languages, D.2.4, F.3.1},
	file = {Lehmann et al. - 2022 - Flux Liquid Types for Rust.pdf:/home/csicar/Zotero/storage/PEE6XE5M/Lehmann et al. - 2022 - Flux Liquid Types for Rust.pdf:application/pdf},
}

@book{pierce_types_2002-2,
	location = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	pagetotal = {623},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002},
	langid = {english},
	keywords = {Programming languages (Electronic computers)},
	file = {Pierce - 2002 - Types and programming languages.pdf:/home/csicar/Zotero/storage/J5Z9XND3/Pierce - 2002 - Types and programming languages.pdf:application/pdf},
}

@inproceedings{wadler_theorems_1989,
	location = {New York, {NY}, {USA}},
	title = {Theorems for free!},
	isbn = {978-0-89791-328-7},
	url = {https://doi.org/10.1145/99370.99404},
	doi = {10.1145/99370.99404},
	series = {{FPCA} '89},
	pages = {347--359},
	booktitle = {Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	publisher = {Association for Computing Machinery},
	author = {Wadler, Philip},
	urldate = {2022-08-29},
	date = {1989-11-01},
	file = {Full Text PDF:/home/csicar/Zotero/storage/BJCCZB9T/Wadler - 1989 - Theorems for free!.pdf:application/pdf},
}

@book{pierce_types_2002-3,
	title = {Types and Programming Languages},
	isbn = {978-0-262-16209-8},
	abstract = {A comprehensive introduction to type systems and programming languages.A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems—and of programming languages from a type-theoretic perspective—has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.},
	pagetotal = {656},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002-01-04},
	langid = {english},
	note = {Google-Books-{ID}: ti6zoAC9Ph8C},
	keywords = {Computers / Languages / General},
	file = {Pierce - 2002 - Types and Programming Languages.pdf:/home/csicar/Zotero/storage/IYSAZ4VI/Pierce - 2002 - Types and Programming Languages.pdf:application/pdf},
}

@book{rondon_liquid_2008-1,
	location = {La Jolla, Calif},
	title = {Liquid types. Technical Report {CSE} Tech Report},
	series = {Technical report (University of California, San Diego. Department of Computer Science and Engineering) ; no. {CS}07-903.},
	shorttitle = {Liquid types},
	abstract = {Predicate abstraction and {ML} type inference are two well-known program analyses with very complementary strengths. The former is a technique for inferring precise, local, path-sensitive properties of base data values like integers but which is thwarted by complex data types and higher-order functions. The latter elegantly captures coarse properties of recursive data types and higher order functions. We present {\textbackslash}emph\{Liquid Types\}, a system that synergistically combines the complementary strengths of predicate abstraction and {ML} type inference to yield an algorithm for statically inferring properties well beyond the scope of either technique. We have implemented liquid type inference for \${\textbackslash}lang\$, an extension of the \${\textbackslash}lambda\$-calculus with recursive types and {ML} style polymorphism. We present examples showing how liquid types can be used to statically prove the absence of divide-by-zero errors, out-of-bounds array access errors, and pattern match errors, with little to no user annotation.},
	publisher = {Dept. of Computer Science and Engineering, University of California, San Diego},
	author = {Rondon, Patrick},
	editora = {Jhala, Ranjit},
	editoratype = {collaborator},
	date = {2008},
	keywords = {Abstract data types (Computer science), Algorithmes, Analyse, Analysis, Computer algorithms, Computer software, Development, Développement, Error functions, Fonctions d'erreur, Logiciels, Technique, Types abstraits de données (Informatique)},
	file = {Rondon - 2008 - Liquid types. Technical Report CSE Tech Report.pdf:/home/csicar/Zotero/storage/9M4KC3FE/Rondon - 2008 - Liquid types. Technical Report CSE Tech Report.pdf:application/pdf},
}

@inproceedings{rondon_low-level_2010,
	location = {New York, {NY}, {USA}},
	title = {Low-level liquid types},
	isbn = {978-1-60558-479-9},
	url = {https://doi.org/10.1145/1706299.1706316},
	doi = {10.1145/1706299.1706316},
	series = {{POPL} '10},
	abstract = {We present Low-Level Liquid Types , a refinement type system for C based on Liquid Types . Low-Level Liquid Types combine refinement types with three key elements to automate verification of critical safety properties of low-level programs: First, by associating refinement types with individual heap locations and precisely tracking the locations referenced by pointers, our system is able to reason about complex invariants of in-memory data structures and sophisticated uses of pointer arithmetic. Second, by adding constructs which allow strong updates to the types of heap locations, even in the presence of aliasing, our system is able to verify properties of in-memory data structures in spite of temporary invariant violations. By using this strong update mechanism, our system is able to verify the correct initialization of newly-allocated regions of memory. Third, by using the abstract interpretation framework of Liquid Types, we are able to use refinement type inference to automatically verify important safety properties without imposing an onerous annotation burden. We have implemented our approach in {CSOLVE}, a tool for Low-Level Liquid Type inference for C programs. We demonstrate through several examples that {CSOLVE} is able to precisely infer complex invariants required to verify important safety properties, like the absence of array bounds violations and null-dereferences, with a minimal annotation overhead.},
	pages = {131--144},
	booktitle = {Proceedings of the 37th annual {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Rondon, Patrick Maxim and Kawaguchi, Ming and Jhala, Ranjit},
	urldate = {2022-09-16},
	date = {2010-01-17},
	keywords = {c, dependent types, liquid types, type inference},
	file = {low_level_liquid_types.pdf:/home/csicar/Zotero/storage/R2CS6AQV/low_level_liquid_types.pdf:application/pdf},
}

@online{noauthor_overview_nodate,
	title = {Overview of the Compiler - Guide to Rustc Development},
	url = {https://rustc-dev-guide.rust-lang.org/overview.html},
	urldate = {2022-09-19},
	file = {Overview of the Compiler - Guide to Rustc Development:/home/csicar/Zotero/storage/IYS7LRS5/overview.html:text/html},
}

@online{noauthor_thir_nodate,
	title = {The {THIR} (Typed High-level {IR}) - Guide to Rustc Development},
	url = {https://rustc-dev-guide.rust-lang.org/thir.html},
	urldate = {2022-09-19},
	file = {The THIR (Typed High-level IR) - Guide to Rustc Development:/home/csicar/Zotero/storage/6GNRFN7I/thir.html:text/html},
}

@article{grossman_region-based_nodate,
	title = {Region-Based Memory Management in Cyclone},
	abstract = {Cyclone is a type-safe programming language derived from C. The primary design goal of Cyclone is to let programmers control data representation and memory management without sacriﬁcing type-safety. In this paper, we focus on the region-based memory management of Cyclone and its static typing discipline. The design incorporates several advancements, including support for region subtyping and a coherent integration with stack allocation and a garbage collector. To support separate compilation, Cyclone requires programmers to write some explicit region annotations, but a combination of default annotations, local type inference, and a novel treatment of region eﬀects reduces this burden. As a result, we integrate C idioms in a region-based framework. In our experience, porting legacy C to Cyclone has required altering about 8\% of the code; of the changes, only 6\% (of the 8\%) were region annotations.},
	pages = {12},
	author = {Grossman, Dan and Morrisett, Greg and Jim, Trevor and Hicks, Michael and Wang, Yanling and Cheney, James},
	langid = {english},
	file = {Grossman et al. - Region-Based Memory Management in Cyclone.pdf:/home/csicar/Zotero/storage/CMDVC47I/Grossman et al. - Region-Based Memory Management in Cyclone.pdf:application/pdf},
}

@inproceedings{sabry_reasoning_1993,
	title = {Reasoning about Programs in Continuation-Passing Style},
	abstract = {Plotkin's v -calculus for call-by-value programs is weaker than the fij-  calculus for the same programs in continuation-passing style ({CPS}). To identify the call-by -value axioms that correspond to fij on {CPS} terms, we define a new {CPS} transformation and an inverse mapping, both of which are interesting in their own right. Using the new {CPS} transformation, we determine the precise language of {CPS} terms closed under  fij-transformations, as well as the call-by-value axioms that correspond to the so-called administrative fij-reductions on {CPS} terms. Using the inverse mapping, we map the remaining fi and j equalities on {CPS} terms to axioms on call-by-value terms. On the pure (constant free) set of-terms, the resulting set of axioms is equivalent to Moggi's computational -calculus. If the call-by-value language includes the control operators  abort and call-with-current-continuation, the axioms are equivalent to an extension of Felleisen et al.'s v-C-calculus and to the equational subtheory of Talcott's logic {IOCC}.},
	pages = {288--298},
	booktitle = {Lisp and Symbolic Computation},
	author = {Sabry, Amr and Felleisen, Matthias},
	date = {1993},
	file = {Citeseer - Full Text PDF:/home/csicar/Zotero/storage/SPH5PCZ3/Sabry und Felleisen - 1993 - Reasoning about Programs in Continuation-Passing S.pdf:application/pdf;Citeseer - Snapshot:/home/csicar/Zotero/storage/K8DPG7QV/summary.html:text/html},
}

@article{matsakis_rust_2014,
	title = {The rust language},
	volume = {34},
	issn = {1094-3641},
	url = {https://doi.org/10.1145/2692956.2663188},
	doi = {10.1145/2692956.2663188},
	abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety. Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
	pages = {103--104},
	number = {3},
	journaltitle = {{ACM} {SIGAda} Ada Letters},
	shortjournal = {Ada Lett.},
	author = {Matsakis, Nicholas D. and Klock, Felix S.},
	urldate = {2022-09-26},
	date = {2014-10-18},
	keywords = {affine type systems, memory management, rust, systems programming},
}

@online{foufas_why_2022,
	title = {Why Volvo thinks you should have Rust in your car},
	url = {https://medium.com/volvo-cars-engineering/why-volvo-thinks-you-should-have-rust-in-your-car-4320bd639e09},
	abstract = {An interview where we talk about how we use embedded Rust in our coming car projects.},
	titleaddon = {Volvo Cars Engineering},
	author = {Foufas, Johannes},
	urldate = {2022-09-26},
	date = {2022-09-23},
	langid = {english},
	file = {Snapshot:/home/csicar/Zotero/storage/TJVYSEJF/why-volvo-thinks-you-should-have-rust-in-your-car-4320bd639e09.html:text/html},
}

@online{larabel_lpc_2022,
	title = {{LPC} 2022: Rust Linux Drivers Capable Of Achieving Performance Comparable To C Code},
	url = {https://www.phoronix.com/news/LPC-2022-Rust-Linux},
	shorttitle = {{LPC} 2022},
	abstract = {Held today during the first day of Linux Plumbers Conference 2022 in Dublin was a Rust mini-conference about the ongoing work on making Rust a suitable systems programming language and integrating support for Rust within the mainline Linux kernel},
	titleaddon = {phoronix},
	author = {Larabel, Michael},
	urldate = {2022-09-26},
	date = {2022-09-12},
	langid = {english},
	file = {Snapshot:/home/csicar/Zotero/storage/AT73GMI8/LPC-2022-Rust-Linux.html:text/html},
}

@misc{lehmann_flux_2022-1,
	title = {Flux: Liquid Types for Rust},
	url = {http://arxiv.org/abs/2207.04034},
	doi = {10.48550/arXiv.2207.04034},
	shorttitle = {Flux},
	abstract = {Low-level pointer-manipulating programs are hard to verify, requiring complex spatial program logics that support reasoning about aliasing and separation. Worse, when working over collections, these logics burden the programmer with annotating loops with quantified invariants that describe the contents of the collection. We present Flux, which shows how logical refinements can work hand in glove with Rust's ownership mechanisms to yield ergonomic type-based verification for low-level imperative code. To do so Flux indexes mutable locations, with pure (immutable) values that can appear in the refinements, and then exploits Rust's ownership mechanisms to abstract sub-structural reasoning about locations within Rust's polymorphic type constructors, extended by a notion of strong references to idiomatically track strong updates. By factoring complex invariants into type constructors and simple refinements, Flux can efficiently synthesize loop annotations via liquid inference. We use a suite of vector-manipulating programs to demonstrate the advantages of Flux's refinement types over program logics, as implemented in the state-of-the-art Prusti verifier. We show that liquid typing makes verification ergonomic by slashing specification lines by a factor of two, verification time by an order of magnitude, and invariant annotation overhead from 14\% of code size, to nothing at all.},
	number = {{arXiv}:2207.04034},
	publisher = {{arXiv}},
	author = {Lehmann, Nico and Geller, Adam and Barthe, Gilles and Vazou, Niki and Jhala, Ranjit},
	urldate = {2022-09-27},
	date = {2022-07-08},
	eprinttype = {arxiv},
	eprint = {2207.04034 [cs]},
	keywords = {Computer Science - Programming Languages, D.2.4, F.3.1},
	file = {arXiv Fulltext PDF:/home/csicar/Zotero/storage/53HMJBRU/Lehmann et al. - 2022 - Flux Liquid Types for Rust.pdf:application/pdf;arXiv.org Snapshot:/home/csicar/Zotero/storage/KM7T2R3U/2207.html:text/html},
}

@online{noauthor_refinement_nodate,
	title = {Refinement Types: A Tutorial},
	url = {https://ieeexplore.ieee.org/abstract/document/9562475/},
	shorttitle = {Refinement Types},
	abstract = {Refinement types can be the vector that brings formal verification into mainstream software development. This happy outcome hinges upon the design and implementation of refinement type systems that can be retrofitted to existing languages, or co-designed with new ones. In this book, the authors catalyze the development of such systems by distilling the ideas developed in the sprawling literature on the topic into a coherent and unified tutorial that explains the key ingredients of modern refinement type systems, by showing how to implement a refinement type checker. Inspired by the nanopass framework for teaching compilation the authors show how to implement refinement types via a progression of languages that incrementally add features to the language or type system. The readily accessible book provides the reader with an insightful introduction into Refinement Types using an innovative tutorial style that enables fast learning. Furthermore, the accompanying software implementation allows readers to work on practical real-world examples.},
	urldate = {2022-09-27},
	langid = {american},
	file = {Snapshot:/home/csicar/Zotero/storage/S2NS2IWA/9562475.html:text/html},
}

@misc{jhala_refinement_2020,
	title = {Refinement Types: A Tutorial},
	url = {http://arxiv.org/abs/2010.07763},
	doi = {10.48550/arXiv.2010.07763},
	shorttitle = {Refinement Types},
	abstract = {Refinement types enrich a language's type system with logical predicates that circumscribe the set of values described by the type, thereby providing software developers a tunable knob with which to inform the type system about what invariants and correctness properties should be checked on their code. In this article, we distill the ideas developed in the substantial literature on refinement types into a unified tutorial that explains the key ingredients of modern refinement type systems. In particular, we show how to implement a refinement type checker via a progression of languages that incrementally add features to the language or type system.},
	number = {{arXiv}:2010.07763},
	publisher = {{arXiv}},
	author = {Jhala, Ranjit and Vazou, Niki},
	urldate = {2022-09-27},
	date = {2020-10-15},
	eprinttype = {arxiv},
	eprint = {2010.07763 [cs]},
	keywords = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science, Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:/home/csicar/Zotero/storage/C4C9U2ZH/Jhala und Vazou - 2020 - Refinement Types A Tutorial.pdf:application/pdf;arXiv.org Snapshot:/home/csicar/Zotero/storage/G3VGDQI7/2010.html:text/html},
}

@software{jung_minirust_2022,
	title = {{MiniRust}},
	rights = {Apache-2.0},
	url = {https://github.com/RalfJung/minirust},
	abstract = {A precise specification for "Rust lite / {MIR} plus"},
	author = {Jung, Ralf},
	urldate = {2022-09-28},
	date = {2022-09-28},
	note = {original-date: 2022-05-21T15:30:40Z},
}

@article{freeman_refinement_1991,
	title = {Refinement types for {ML}},
	volume = {26},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/113446.113468},
	doi = {10.1145/113446.113468},
	pages = {268--277},
	number = {6},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Freeman, Tim and Pfenning, Frank},
	urldate = {2022-09-29},
	date = {1991-05-01},
	file = {Full Text PDF:/home/csicar/Zotero/storage/XVXD3KNV/Freeman und Pfenning - 1991 - Refinement types for ML.pdf:application/pdf},
}

@inproceedings{xi_dependent_1999,
	location = {New York, {NY}, {USA}},
	title = {Dependent types in practical programming},
	isbn = {978-1-58113-095-9},
	url = {https://doi.org/10.1145/292540.292560},
	doi = {10.1145/292540.292560},
	series = {{POPL} '99},
	abstract = {We present an approach to enriching the type system of {ML} with a restricted form of dependent types, where type index objects are drawn from a constraint domain C, leading to the {DML}(C) language schema. This allows specification and inference of significantly more precise type information, facilitating program error detection and compiler optimization. A major complication resulting from introducing dependent types is that pure type inference for the enriched system is no longer possible, but we show that type-checking a sufficiently annotated program in {DML}(C) can be reduced to constraint satisfaction in the constraint domain C. We exhibit the unobtrusiveness of our approach through practical examples and prove that {DML}(C) is conservative over {ML}. The main contribution of the paper lies in our language design, including the formulation of type-checking rules which makes the approach practical. To our knowledge, no previous type system for a general purpose programming language such as {ML} has combined dependent types with features including datatype declarations, higher-order functions, general recursions, let-polymorphism, mutable references, and exceptions. In addition, we have finished a prototype implementation of {DML}(C) for an integer constraint domain C, where constraints are linear inequalities (Xi and Pfenning 1998).},
	pages = {214--227},
	booktitle = {Proceedings of the 26th {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Xi, Hongwei and Pfenning, Frank},
	urldate = {2022-09-29},
	date = {1999-01-01},
	file = {Full Text PDF:/home/csicar/Zotero/storage/F9E4AIJC/Xi und Pfenning - 1999 - Dependent types in practical programming.pdf:application/pdf},
}

@inproceedings{bakst_predicate_2016,
	location = {Berlin, Heidelberg},
	title = {Predicate Abstraction for Linked Data Structures},
	isbn = {978-3-662-49122-5},
	doi = {10.1007/978-3-662-49122-5_3},
	series = {Lecture Notes in Computer Science},
	abstract = {We present Alias Refinement Types (Art), a new approach that uses predicate-abstraction to automate the verification of correctness properties of linked data structures. While there are many techniques for checking that a heap-manipulating program adheres to its specification, they often require that the programmer annotate the behavior of each procedure, for example, in the form of loop invariants and pre- and post-conditions. We introduce a technique that lifts predicate abstraction to the heap by factoring the analysis of data structures into two orthogonal components: (1) Alias Types, which reason about the physical shape of heap structures, and (2) Refinement Types, which use simple predicates from an {SMT} decidable theory to capture the logical or semantic properties of the structures. We evaluate Art by implementing a tool that performs type inference for an imperative language, and empirically show, using a suite of data-structure benchmarks, that Art requires only 21 \% of the annotations needed by other state-of-the-art verification techniques.},
	pages = {65--84},
	booktitle = {Verification, Model Checking, and Abstract Interpretation},
	publisher = {Springer},
	author = {Bakst, Alexander and Jhala, Ranjit},
	editor = {Jobstmann, Barbara and Leino, K. Rustan M.},
	date = {2016},
	langid = {english},
	keywords = {Binary Search Tree, Horn Clause, Symbolic Execution, Type Inference, Type System},
	file = {Full Text PDF:/home/csicar/Zotero/storage/Q3YZFHMD/Bakst und Jhala - 2016 - Predicate Abstraction for Linked Data Structures.pdf:application/pdf},
}

@inproceedings{sammler_refinedc_2021,
	location = {New York, {NY}, {USA}},
	title = {{RefinedC}: automating the foundational verification of C code with refined ownership types},
	isbn = {978-1-4503-8391-2},
	url = {https://doi.org/10.1145/3453483.3454036},
	doi = {10.1145/3453483.3454036},
	series = {{PLDI} 2021},
	shorttitle = {{RefinedC}},
	abstract = {Given the central role that C continues to play in systems software, and the difficulty of writing safe and correct C code, it remains a grand challenge to develop effective formal methods for verifying C programs. In this paper, we propose a new approach to this problem: a type system we call {RefinedC}, which combines ownership types (for modular reasoning about shared state and concurrency) with refinement types (for encoding precise invariants on C data types and Hoare-style specifications for C functions). {RefinedC} is both automated (requiring minimal user intervention) and foundational (producing a proof of program correctness in Coq), while at the same time handling a range of low-level programming idioms such as pointer arithmetic. In particular, following the approach of {RustBelt}, the soundness of the {RefinedC} type system is justified semantically by interpretation into the Coq-based Iris framework for higher-order concurrent separation logic. However, the typing rules of {RefinedC} are also designed to be encodable in a new “separation logic programming” language we call Lithium. By restricting to a carefully chosen (yet expressive) fragment of separation logic, Lithium supports predictable, automatic, goal-directed proof search without backtracking. We demonstrate the effectiveness of {RefinedC} on a range of representative examples of C code.},
	pages = {158--174},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} International Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Sammler, Michael and Lepigre, Rodolphe and Krebbers, Robbert and Memarian, Kayvan and Dreyer, Derek and Garg, Deepak},
	urldate = {2022-09-29},
	date = {2021-06-19},
	keywords = {C programming language, Coq, Iris, ownership types, proof automation, refinement types, separation logic},
	file = {Full Text PDF:/home/csicar/Zotero/storage/CI9LVY2K/Sammler et al. - 2021 - RefinedC automating the foundational verification.pdf:application/pdf},
}

@inproceedings{de_moura_lean_2015,
	location = {Cham},
	title = {The Lean Theorem Prover (System Description)},
	isbn = {978-3-319-21401-6},
	doi = {10.1007/978-3-319-21401-6_26},
	series = {Lecture Notes in Computer Science},
	abstract = {Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich {API} which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.},
	pages = {378--388},
	booktitle = {Automated Deduction - {CADE}-25},
	publisher = {Springer International Publishing},
	author = {de Moura, Leonardo and Kong, Soonho and Avigad, Jeremy and van Doorn, Floris and von Raumer, Jakob},
	editor = {Felty, Amy P. and Middeldorp, Aart},
	date = {2015},
	langid = {english},
	keywords = {Automate Theorem Prove, Theorem Prove, Trust Level, Type Checker, Type Class},
	file = {Full Text PDF:/home/csicar/Zotero/storage/NHKYSAD8/de Moura et al. - 2015 - The Lean Theorem Prover (System Description).pdf:application/pdf},
}

@article{harper_practical_nodate,
	title = {Practical Foundations for Programming Languages},
	pages = {518},
	author = {Harper, Robert},
	langid = {english},
	file = {Harper - Practical Foundations for Programming Languages.pdf:/home/csicar/Zotero/storage/JNC5CIU3/Harper - Practical Foundations for Programming Languages.pdf:application/pdf},
}

@article{wright_syntactic_1994,
	title = {A Syntactic Approach to Type Soundness},
	volume = {115},
	issn = {0890-5401},
	url = {https://www.sciencedirect.com/science/article/pii/S0890540184710935},
	doi = {10.1006/inco.1994.1093},
	abstract = {We present a new approach to proving type soundness for Hindley/Milner-style polymorphic type systems. The keys to our approach are (1) an adaptation of subject reduction theorems from combinatory logic to programming languages, and (2) the use of rewriting techniques for the specification of the language semantics. The approach easily extends from polymorphic functional languages to imperative languages that provide references, exceptions, continuations, and similar features. We illustrate the technique with a type soundness theorem for the core of Standard {ML}, which includes the first type soundness proof for polymorphic exceptions and continuations.},
	pages = {38--94},
	number = {1},
	journaltitle = {Information and Computation},
	shortjournal = {Information and Computation},
	author = {Wright, A. K. and Felleisen, M.},
	urldate = {2022-10-03},
	date = {1994-11-15},
	langid = {english},
	file = {out.pdf:/home/csicar/Zotero/storage/QLNB8WQN/out.pdf:application/pdf;ScienceDirect Full Text PDF:/home/csicar/Zotero/storage/HNYULK3F/Wright und Felleisen - 1994 - A Syntactic Approach to Type Soundness.pdf:application/pdf;ScienceDirect Snapshot:/home/csicar/Zotero/storage/6HYPKGTC/S0890540184710935.html:text/html},
}

@online{bachmeier_property_2022,
	title = {Property Types for Mutable Data Structures in Java},
	url = {https://publikationen.bibliothek.kit.edu/1000150318},
	abstract = {Property Types are a kind of user-defined refinement type about variables and fields in a program. They are verified by discharging as many properties as possible using a scalable type checker. The remaining assertions are forwarded to a less scalable but more powerful deductive verification tool. However, the design and implementation by Lanzinger et al. cannot function in the presence of aliasing and mutability. In this thesis, we find that property checking can be performed safely on mutable data structures provided exclusive mutable access to the referenced object, which we define as property-safety. We study different approaches to aliasing control, including uniqueness, ownership and permissions. Based on this research, we present the Exclusivity Type System, which can be used to check the property-safety of program variables and class fields. Using flow-sensitive type refinement, we develop Mutable Property Types, which can track changes in a variable’s property type over time. Impure methods can be annotated to specify how they change the Property Types of their receiver and arguments. We explain how the original Property Checker’s program translation can be adapted to include correct assertions about the pre- and post-types of each method. We present a prototypical implementation of the Exclusivity Checker for Java programs using the Checker Framework. Our work provides many insights into the nature of property type verification on mutable data structures and we devise the theoretical groundwork for performing this verification. To corroborate the reasonableness of the presented approach, we suggest a thorough analysis of our systems through formal proofs.},
	author = {Bachmeier, Joshua},
	urldate = {2022-10-03},
	date = {2022},
	langid = {german},
	doi = {10.5445/IR/1000150318},
	file = {Full Text PDF:/home/csicar/Zotero/storage/DNINYH9D/Bachmeier - 2022 - Property Types for Mutable Data Structures in Java.pdf:application/pdf;Snapshot:/home/csicar/Zotero/storage/DH9C2CR6/1000150318.html:text/html},
}

@article{foster_combinators_2007,
	title = {Combinators for bidirectional tree transformations: A linguistic approach to the view-update problem},
	volume = {29},
	issn = {0164-0925},
	url = {https://doi.org/10.1145/1232420.1232424},
	doi = {10.1145/1232420.1232424},
	shorttitle = {Combinators for bidirectional tree transformations},
	abstract = {We propose a novel approach to the view-update problem for tree-structured data: a domain-specific programming language in which all expressions denote bidirectional transformations on trees. In one direction, these transformations---dubbed lenses---map a concrete tree into a simplified abstract view; in the other, they map a modified abstract view, together with the original concrete tree, to a correspondingly modified concrete tree. Our design emphasizes both robustness and ease of use, guaranteeing strong well-behavedness and totality properties for well-typed lenses. We begin by identifying a natural space of well-behaved bidirectional transformations over arbitrary structures, studying definedness and continuity in this setting. We then instantiate this semantic framework in the form of a collection of lens combinators that can be assembled to describe bidirectional transformations on trees. These combinators include familiar constructs from functional programming (composition, mapping, projection, conditionals, recursion) together with some novel primitives for manipulating trees (splitting, pruning, merging, etc.). We illustrate the expressiveness of these combinators by developing a number of bidirectional list-processing transformations as derived forms. An extended example shows how our combinators can be used to define a lens that translates between a native {HTML} representation of browser bookmarks and a generic abstract bookmark format.},
	pages = {17--es},
	number = {3},
	journaltitle = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Foster, J. Nathan and Greenwald, Michael B. and Moore, Jonathan T. and Pierce, Benjamin C. and Schmitt, Alan},
	urldate = {2022-10-03},
	date = {2007-05-01},
	keywords = {Bidirectional programming, Harmony, lenses, view update problem, {XML}},
	file = {Full Text PDF:/home/csicar/Zotero/storage/2A3K52U5/Foster et al. - 2007 - Combinators for bidirectional tree transformations.pdf:application/pdf},
}

@online{noauthor_announcing_2022,
	title = {Announcing the Kani Rust Verifier Project},
	url = {https://model-checking.github.io//kani-verifier-blog/2022/05/04/announcing-the-kani-rust-verifier-project.html},
	abstract = {The Kani Rust Verifier (Kani) is an open-source automated reasoning tool that proves properties about Rust code. This is our blog for the project.},
	titleaddon = {Kani Rust Verifier Blog},
	urldate = {2022-10-03},
	date = {2022-05-04},
	langid = {english},
	file = {Snapshot:/home/csicar/Zotero/storage/MNRCFCRP/announcing-the-kani-rust-verifier-project.html:text/html},
}

@inproceedings{toman_crust_2015,
	title = {Crust: A Bounded Verifier for Rust (N)},
	doi = {10.1109/ASE.2015.77},
	shorttitle = {Crust},
	abstract = {Rust is a modern systems language that provides guaranteed memory safety through static analysis. However, Rust includes an escape hatch in the form of "unsafe code," which the compiler assumes to be memory safe and to preserve crucial pointer aliasing invariants. Unsafe code appears in many data structure implementations and other essential libraries, and bugs in this code can lead to memory safety violations in parts of the program that the compiler otherwise proved safe. We present {CRUST}, a tool combining exhaustive test generation and bounded model checking to detect memory safety errors, as well as violations of Rust's pointer aliasing invariants within unsafe library code. {CRUST} requires no programmer annotations, only an indication of the modules to check. We evaluate {CRUSTon} data structures from the Rust standard library. It detects memory safety bugs that arose during the library's development and remained undetected for several months.},
	eventtitle = {2015 30th {IEEE}/{ACM} International Conference on Automated Software Engineering ({ASE})},
	pages = {75--80},
	booktitle = {2015 30th {IEEE}/{ACM} International Conference on Automated Software Engineering ({ASE})},
	author = {Toman, John and Pernsteiner, Stuart and Torlak, Emina},
	date = {2015-11},
	keywords = {Arrays, Computer bugs, Indexes, Libraries, memory safety, Safety, {SMT}-based verification, Standards, test generation},
	file = {IEEE Xplore Abstract Record:/home/csicar/Zotero/storage/WSW7RZG6/7371997.html:text/html},
}
