
@article{erdin_verication_nodate,
	title = {Veriﬁcation of Rust Generics, Typestates, and Traits},
	pages = {75},
	author = {Erdin, Matthias},
	langid = {english},
	file = {Erdin - Veriﬁcation of Rust Generics, Typestates, and Trai.pdf:/home/csicar/Zotero/storage/UIQXBPV7/Erdin - Veriﬁcation of Rust Generics, Typestates, and Trai.pdf:application/pdf},
}

@thesis{denis_creusot_2021,
	title = {The Creusot Environment for the Deductive Verification of Rust Programs},
	institution = {Inria Saclay-Île de France},
	type = {phdthesis},
	author = {Denis, Xavier and Jourdan, Jacques-Henri and Marché, Claude},
	date = {2021},
	file = {Full Text:/home/csicar/Zotero/storage/IQIUWIZQ/Denis et al. - 2021 - The Creusot Environment for the Deductive Verifica.pdf:application/pdf;Snapshot:/home/csicar/Zotero/storage/K7HUXUK5/hal-03526634.html:text/html},
}

@inproceedings{matsushita_rusthorn_2020,
	title = {{RustHorn}: {CHC}-based verification for Rust programs},
	shorttitle = {{RustHorn}},
	pages = {484--514},
	booktitle = {European Symposium on Programming},
	publisher = {Springer, Cham},
	author = {Matsushita, Yusuke and Tsukada, Takeshi and Kobayashi, Naoki},
	date = {2020},
	file = {Full Text:/home/csicar/Zotero/storage/IV87RRRX/Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:application/pdf;Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:/home/csicar/Zotero/storage/TW2TN794/Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:application/pdf},
}

@article{beckmann_verifying_2020,
	title = {Verifying Safe Clients of Unsafe Code and Trait Implementations in Rust},
	author = {Beckmann, Jakob},
	date = {2020},
	file = {Full Text:/home/csicar/Zotero/storage/7W24IZJG/Beckmann - 2020 - Verifying Safe Clients of Unsafe Code and Trait Im.pdf:application/pdf},
}

@article{reed_patina_2015,
	title = {Patina: A formalization of the Rust programming language},
	shorttitle = {Patina},
	pages = {264},
	journaltitle = {University of Washington, Department of Computer Science and Engineering, Tech. Rep. {UW}-{CSE}-15-03-02},
	author = {Reed, Eric},
	date = {2015},
	file = {Full Text:/home/csicar/Zotero/storage/5ZNMKC3P/Reed - 2015 - Patina A formalization of the Rust programming la.pdf:application/pdf},
}

@article{gordon_rely-guarantee_nodate,
	title = {Rely-Guarantee References for Reﬁnement Types Over Aliased Mutable Data (Extended Version ∗)},
	abstract = {Reasoning about side effects and aliasing is the heart of verifying imperative programs. Unrestricted side effects through one reference can invalidate assumptions about an alias. We present a new type system approach to reasoning about safe assumptions in the presence of aliasing and side effects, unifying ideas from reference immutability type systems and rely-guarantee program logics. Our approach, rely-guarantee references, treats multiple references to shared objects similarly to multiple threads in rely-guarantee program logics. We propose statically associating rely and guarantee conditions with individual references to shared objects. Multiple aliases to a given object may coexist only if the guarantee condition of each alias implies the rely condition for all other aliases. We demonstrate that existing reference immutability type systems are special cases of rely-guarantee references.},
	pages = {21},
	author = {Gordon, Colin S and Ernst, Michael D and Grossman, Dan},
	langid = {english},
	file = {Gordon et al. - Rely-Guarantee References for Reﬁnement Types Over.pdf:/home/csicar/Zotero/storage/8XFSDE5Z/Gordon et al. - Rely-Guarantee References for Reﬁnement Types Over.pdf:application/pdf},
}

@inproceedings{sato_combining_2019,
	location = {Cascais, Portugal},
	title = {Combining higher-order model checking with refinement type inference},
	isbn = {978-1-4503-6226-9},
	url = {http://dl.acm.org/citation.cfm?doid=3294032.3294081},
	doi = {10.1145/3294032.3294081},
	abstract = {There have been two major approaches to fully automated verification of higher-order functional programs: higherorder model checking and refinement type inference. The former approach is precise, but suffers from a bottleneck in the predicate discovery phase. The latter approach is generally faster than the former, thanks to the recent advances in constrained Horn clause ({CHC}) solving, but is imprecise, in that it rejects some valid programs. To take the best of the two approaches, we refine the higher-order model checking approach, by employing {CHC} solving in the predicate discovery phase. We have implemented the new approach and confirmed that the new system can verify more programs than those based on the previous two approaches.},
	eventtitle = {the 2019 {ACM} {SIGPLAN} Workshop},
	pages = {47--53},
	booktitle = {Proceedings of the 2019 {ACM} {SIGPLAN} Workshop on Partial Evaluation and Program Manipulation  - {PEPM} 2019},
	publisher = {{ACM} Press},
	author = {Sato, Ryosuke and Iwayama, Naoki and Kobayashi, Naoki},
	urldate = {2022-01-27},
	date = {2019},
	langid = {english},
	file = {Sato et al. - 2019 - Combining higher-order model checking with refinem.pdf:/home/csicar/Zotero/storage/23RTH8SA/Sato et al. - 2019 - Combining higher-order model checking with refinem.pdf:application/pdf},
}

@inproceedings{oconnor_refinement_2016,
	location = {Nara Japan},
	title = {Refinement through restraint: bringing down the cost of verification},
	isbn = {978-1-4503-4219-3},
	url = {https://dl.acm.org/doi/10.1145/2951913.2951940},
	doi = {10.1145/2951913.2951940},
	shorttitle = {Refinement through restraint},
	abstract = {We present a framework aimed at signiﬁcantly reducing the cost of verifying certain classes of systems software, such as ﬁle systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for eﬃcient C code generation; and one functional, suitable for equational reasoning and veriﬁcation. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C veriﬁcation frameworks.},
	eventtitle = {{ICFP}'16: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {89--102},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {O'Connor, Liam and Chen, Zilin and Rizkallah, Christine and Amani, Sidney and Lim, Japheth and Murray, Toby and Nagashima, Yutaka and Sewell, Thomas and Klein, Gerwin},
	urldate = {2022-01-27},
	date = {2016-09-04},
	langid = {english},
	file = {O'Connor et al. - 2016 - Refinement through restraint bringing down the co.pdf:/home/csicar/Zotero/storage/VGLKJBTZ/O'Connor et al. - 2016 - Refinement through restraint bringing down the co.pdf:application/pdf},
}

@article{weiss_oxide_2021,
	title = {Oxide: The Essence of Rust},
	url = {http://arxiv.org/abs/1903.00982},
	shorttitle = {Oxide},
	abstract = {Rust claims to advance industrial programming by bridging the gap between low-level systems programming and high-level application programming. At the heart of the argument that this enables programmers to build more reliable and efficient software is the borrow checker - a novel approach to ownership that aims to balance type system expressivity with usability. And yet, to date there is no core type system that captures Rust's notion of ownership and borrowing, and hence no foundation for research on Rust to build upon. In this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. We present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as an approximation of the provenances of references, and our type system is able to automatically compute this information through a substructural typing judgment. We provide the first syntactic proof of type safety for borrow checking using progress and preservation. Oxide is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.},
	journaltitle = {{arXiv}:1903.00982 [cs]},
	author = {Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Ahmed, Amal},
	urldate = {2022-01-27},
	date = {2021-10-19},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1903.00982},
	keywords = {Computer Science - Programming Languages},
	file = {Weiss et al. - 2021 - Oxide The Essence of Rust.pdf:/home/csicar/Zotero/storage/GEWQA5M8/Weiss et al. - 2021 - Oxide The Essence of Rust.pdf:application/pdf},
}

@article{kloos_asynchronous_2015,
	title = {Asynchronous Liquid Separation Types},
	url = {http://drops.dagstuhl.de/opus/volltexte/2015/5223/},
	doi = {10.4230/LIPICS.ECOOP.2015.396},
	abstract = {We present a reﬁnement type system for reasoning about asynchronous programs manipulating shared mutable state. Our type system guarantees the absence of races and the preservation of user-speciﬁed invariants using a combination of two ideas: reﬁnement types and concurrent separation logic. Our type system allows precise reasoning about programs using two ingredients. First, our types are indexed by sets of resource names and the type system tracks the eﬀect of program execution on individual heap locations and task handles. In particular, it allows making strong updates to the types of heap locations. Second, our types track ownership of shared state across concurrently posted tasks and allow reasoning about ownership transfer between tasks using permissions. We demonstrate through several examples that these two ingredients, on top of the framework of liquid types, are powerful enough to reason about correct behavior of practical, complex, asynchronous systems manipulating shared heap resources.},
	pages = {25 pages},
	author = {Kloos, Johannes and Majumdar, Rupak and Vafeiadis, Viktor},
	editora = {Herbstritt, Marc},
	editoratype = {collaborator},
	urldate = {2022-01-27},
	date = {2015},
	langid = {english},
	note = {Artwork Size: 25 pages
Medium: application/pdf
Publisher: Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik {GmbH}, Wadern/Saarbruecken, Germany},
	keywords = {000 Computer science, knowledge, general works, Computer Science},
	file = {Kloos et al. - 2015 - Asynchronous Liquid Separation Types.pdf:/home/csicar/Zotero/storage/WAE34UL7/Kloos et al. - 2015 - Asynchronous Liquid Separation Types.pdf:application/pdf},
}

@article{jung_rustbelt_2018,
	title = {{RustBelt}: securing the foundations of the Rust programming language},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3158154},
	doi = {10.1145/3158154},
	shorttitle = {{RustBelt}},
	abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
	pages = {1--34},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
	urldate = {2022-02-17},
	date = {2018-01},
	langid = {english},
	file = {Jung et al. - 2018 - RustBelt securing the foundations of the Rust pro.pdf:/home/csicar/Zotero/storage/8PK9HFSL/Jung et al. - 2018 - RustBelt securing the foundations of the Rust pro.pdf:application/pdf},
}

@article{lanzinger_property_nodate,
	title = {Property Types in Java: Combining Type Systems and Deductive Verification},
	pages = {136},
	author = {Lanzinger, Florian},
	langid = {english},
	file = {Lanzinger - Property Types in Java Combining Type Systems and.pdf:/home/csicar/Zotero/storage/XIEBH65B/Lanzinger - Property Types in Java Combining Type Systems and.pdf:application/pdf},
}

@thesis{lanzinger_property_2021,
	title = {Property Types in Java: Combining Type Systems and Deductive Verification},
	institution = {Karlsruher Institut für Technologie},
	type = {Master Thesis},
	author = {Lanzinger, Florian},
	date = {2021-02},
	file = {Lanzinger - Property Types in Java Combining Type Systems and.pdf:/home/csicar/Zotero/storage/BI3XCAJ6/Lanzinger - Property Types in Java Combining Type Systems and.pdf:application/pdf},
}

@article{lanzinger_property_nodate-1,
	title = {Property Types in Java: Combining Type Systems and Deductive Verification},
	pages = {136},
	author = {Lanzinger, Florian},
	langid = {english},
}

@article{astrauskas_how_2020,
	title = {How do programmers use unsafe rust?},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3428204},
	doi = {10.1145/3428204},
	abstract = {Rust’s ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that frequently occur in conventional imperative programs. However, the restrictions imposed by Rust’s type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g. doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as
              unsafe
              and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, an important assumption of the Rust language, which we dub the
              Rust hypothesis
              , is that programmers use Rust by following three main principles: use unsafe code sparingly, make it easy to review, and hide it behind a safe abstraction such that client code can be written in safe Rust.
            
            Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analysing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program’s source code, its intermediate representation {MIR}, as well as type information provided by the Rust compiler; we complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.},
	pages = {1--27},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Astrauskas, Vytautas and Matheja, Christoph and Poli, Federico and Müller, Peter and Summers, Alexander J.},
	urldate = {2022-02-23},
	date = {2020-11-13},
	langid = {english},
	file = {Astrauskas et al. - 2020 - How do programmers use unsafe rust.pdf:/home/csicar/Zotero/storage/TGABAAYT/Astrauskas et al. - 2020 - How do programmers use unsafe rust.pdf:application/pdf},
}

@article{astrauskas_leveraging_2019,
	title = {Leveraging rust types for modular specification and verification},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3360573},
	doi = {10.1145/3360573},
	abstract = {{CCS} Concepts: • General and reference → Verification; • Theory of computation → Programming logic; Separation logic; Program specifications; Program verification; • Software and its engineering → Software verification; Formal software verification.},
	pages = {1--30},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Astrauskas, Vytautas and Müller, Peter and Poli, Federico and Summers, Alexander J.},
	urldate = {2022-02-23},
	date = {2019-10-10},
	langid = {english},
	file = {Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:/home/csicar/Zotero/storage/TUIPHR3X/Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:application/pdf},
}

@article{breaux_2021_2021,
	title = {The 2021 software developer shortage is coming},
	volume = {64},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3440753},
	doi = {10.1145/3440753},
	abstract = {Companies must address the difficulty of hiring and retaining high-skilled employees from an increasingly smaller labor supply.},
	pages = {39--41},
	number = {7},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Breaux, Travis and Moritz, Jennifer},
	urldate = {2022-03-15},
	date = {2021-06-21},
	file = {Full Text PDF:/home/csicar/Zotero/storage/6FCF336Z/Breaux und Moritz - 2021 - The 2021 software developer shortage is coming.pdf:application/pdf},
}

@article{breaux_2021_2021-1,
	title = {The 2021 Software Developer Shortage is Coming},
	volume = {64},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3440753},
	doi = {10.1145/3440753},
	abstract = {Companies must address the difficulty of hiring and retaining high-skilled employees from an increasingly smaller labor supply.},
	pages = {39--41},
	number = {7},
	journaltitle = {Commun. {ACM}},
	author = {Breaux, Travis and Moritz, Jennifer},
	date = {2021-06},
	note = {Place: New York, {NY}, {USA}
Publisher: Association for Computing Machinery},
}

@article{graf_lower_2020,
	title = {Lower your guards: a compositional pattern-match coverage checker},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3408989},
	doi = {10.1145/3408989},
	shorttitle = {Lower your guards},
	abstract = {A compiler should warn if a function defined by pattern matching does not cover its inputs—that is, if there are missing or redundant patterns. Generating such warnings accurately is difficult for modern languages due to the myriad of language features that interact with pattern matching. This is especially true in Haskell, a language with a complicated pattern language that is made even more complex by extensions offered by the Glasgow Haskell Compiler ({GHC}). Although {GHC} has spent a significant amount of effort towards improving its pattern-match coverage warnings, there are still several cases where it reports inaccurate warnings.
            
              We introduce a coverage checking algorithm called Lower Your Guards, which boils down the complexities of pattern matching into
              guard trees
              . While the source language may have many exotic forms of patterns, guard trees only have three different constructs, which vastly simplifies the coverage checking process. Our algorithm is modular, allowing for new forms of source-language patterns to be handled with little changes to the overall structure of the algorithm. We have implemented the algorithm in {GHC} and demonstrate places where it performs better than {GHC}’s current coverage checker, both in accuracy and performance.},
	pages = {1--30},
	issue = {{ICFP}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Graf, Sebastian and Peyton Jones, Simon and Scott, Ryan G.},
	urldate = {2022-03-15},
	date = {2020-08-02},
	langid = {english},
	file = {Graf et al. - 2020 - Lower your guards a compositional pattern-match c.pdf:/home/csicar/Zotero/storage/LEFXNJPB/Graf et al. - 2020 - Lower your guards a compositional pattern-match c.pdf:application/pdf},
}

@inproceedings{vazou_abstract_2013,
	location = {Berlin, Heidelberg},
	title = {Abstract Refinement Types},
	isbn = {978-3-642-37036-6},
	doi = {10.1007/978-3-642-37036-6_13},
	abstract = {We present abstract refinement types which enable quantification over the refinements of data- and function-types. Our key insight is that we can avail of quantification while preserving {SMT}-based decidability, simply by encoding refinement parameters as uninterpreted propositions within the refinement logic. We illustrate how this mechanism yields a variety of sophisticated means for reasoning about programs, including: parametric refinements for reasoning with type classes, index-dependent refinements for reasoning about key-value maps, recursive refinements for reasoning about recursive data types, and inductive refinements for reasoning about higher-order traversal routines. We have implemented our approach in a refinement type checker for Haskell and present experiments using our tool to verify correctness invariants of various programs.},
	pages = {209--228},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Vazou, Niki and Rondon, Patrick M. and Jhala, Ranjit},
	editor = {Felleisen, Matthias and Gardner, Philippa},
	date = {2013},
	langid = {english},
	file = {Springer Full Text PDF:/home/csicar/Zotero/storage/88XPM8P7/Vazou et al. - 2013 - Abstract Refinement Types.pdf:application/pdf},
}

@inproceedings{foster_flow-sensitive_2002,
	location = {New York, {NY}, {USA}},
	title = {Flow-sensitive type qualifiers},
	isbn = {978-1-58113-463-6},
	url = {https://doi.org/10.1145/512529.512531},
	doi = {10.1145/512529.512531},
	series = {{PLDI} '02},
	abstract = {We present a system for extending standard type systems with flow-sensitive type qualifiers. Users annotate their programs with type qualifiers, and inference checks that the annotations are correct. In our system only the type qualifiers are modeled flow-sensitively---the underlying standard types are unchanged, which allows us to obtain an efficient constraint-based inference algorithm that integrates flow-insensitive alias analysis, effect inference, and ideas from linear type systems to support strong updates. We demonstrate the usefulness of flow-sensitive type qualifiers by finding a number of new locking bugs in the Linux kernel.},
	pages = {1--12},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2002 conference on Programming language design and implementation},
	publisher = {Association for Computing Machinery},
	author = {Foster, Jeffrey S. and Terauchi, Tachio and Aiken, Alex},
	urldate = {2022-03-21},
	date = {2002-05-17},
	keywords = {alias analysis, constraints, effect inference, flow-sensitivity, linux kernel, locking, restrict, type qualifiers, types},
	file = {Full Text PDF:/home/csicar/Zotero/storage/RD45TVBX/Foster et al. - 2002 - Flow-sensitive type qualifiers.pdf:application/pdf},
}

@collection{muller_programming_2020,
	title = {Programming Languages and Systems: 29th European Symposium on Programming, {ESOP} 2020, Held as Part of the European Joint Conferences on Theory and Practice of Software, {ETAPS} 2020, Dublin, Ireland, April 25–30, 2020, Proceedings},
	url = {https://library.oapen.org/handle/20.500.12657/37721},
	shorttitle = {Programming Languages and Systems},
	abstract = {This open access book constitutes the proceedings of the 29th European Symposium on Programming, {ESOP} 2020, which was planned to take place in Dublin, Ireland, in April 2020, as Part of the European Joint Conferences on Theory and Practice of Software, {ETAPS} 2020. The actual {ETAPS} 2020 meeting was postponed due to the Corona pandemic. The papers deal with fundamental issues in the specification, design, analysis, and implementation of programming languages and systems.},
	publisher = {Springer Nature},
	editor = {Müller, Peter},
	urldate = {2022-03-21},
	date = {2020},
	doi = {10.1007/978-3-030-44914-8},
	note = {Accepted: 2020-05-13T14:21:46Z},
	keywords = {Algorithms \& data structures, artificial intelligence, bic Book Industry Communication::U Computing \& information technology::{UM} Computer programming / software development::{UMB} Algorithms \& data structures, bic Book Industry Communication::U Computing \& information technology::{UM} Computer programming / software development::{UMX} Programming \& scripting languages: general, bic Book Industry Communication::U Computing \& information technology::{UT} Computer networking \& communications, bic Book Industry Communication::U Computing \& information technology::{UY} Computer science, bic Book Industry Communication::U Computing \& information technology::{UY} Computer science::{UYQ} Artificial intelligence::{UYQL} Natural language \& machine translation, Compilers, Compilers \& interpreters, Computer networking \& communications, computer networks, computer programming, Computer science, computer security, Computer Systems Organization and Communication Networks, Control Structures and Microprogramming, distributed computer systems, embedded systems, formal languages, formal logic, Information Systems and Communication Service, Interpreters, linguistics, Mathematical theory of computation, mathematics, model checking, Natural language \& machine translation, Natural Language Processing ({NLP}), object-oriented programming, parallel processing systems, program compilers, Programming \& scripting languages: general, Programming Languages, semantics, software architecture, software design, software engineering, software quality, Theory of Computation, verification and validation},
	file = {Full Text PDF:/home/csicar/Zotero/storage/U3CDRJXW/Müller - 2020 - Programming Languages and Systems 29th European S.pdf:application/pdf},
}

@online{noauthor_crossmark_nodate,
	title = {Crossmark},
	url = {https://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-44914-8_25&domain=pdf},
	urldate = {2022-03-21},
	file = {Crossmark:/home/csicar/Zotero/storage/Y3HLBDV2/dialog.html:text/html},
}

@inproceedings{toman_consort_2020,
	location = {Cham},
	title = {{ConSORT}: Context- and Flow-Sensitive Ownership Refinement Types for Imperative Programs},
	isbn = {978-3-030-44914-8},
	doi = {10.1007/978-3-030-44914-8_25},
	shorttitle = {{ConSORT}},
	abstract = {We present {ConSORT}, a type system for safety verification in the presence of mutability and aliasing. Mutability requires strong updates to model changing invariants during program execution, but aliasing between pointers makes it difficult to determine which invariants must be updated in response to mutation. Our type system addresses this difficulty with a novel combination of refinement types and fractional ownership types. Fractional ownership types provide flow-sensitive and precise aliasing information for reference variables. {ConSORT} interprets this ownership information to soundly handle strong updates of potentially aliased references. We have proved {ConSORT} sound and implemented a prototype, fully automated inference tool. We evaluated our tool and found it verifies non-trivial programs including data structure implementations.},
	pages = {684--714},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {Toman, John and Siqi, Ren and Suenaga, Kohei and Igarashi, Atsushi and Kobayashi, Naoki},
	editor = {Müller, Peter},
	date = {2020},
	langid = {english},
	file = {Springer Full Text PDF:/home/csicar/Zotero/storage/SV4MFYBL/Toman et al. - 2020 - ConSORT Context- and Flow-Sensitive Ownership Ref.pdf:application/pdf},
}

@article{ullrich_simple_nodate,
	title = {Simple Veriﬁcation of Rust Programs via Functional Puriﬁcation},
	pages = {65},
	author = {Ullrich, Sebastian},
	langid = {english},
	file = {Ullrich - Simple Veriﬁcation of Rust Programs via Functional.pdf:/home/csicar/Zotero/storage/7M7KBPV4/Ullrich - Simple Veriﬁcation of Rust Programs via Functional.pdf:application/pdf},
}

@article{matsushita_rusthornbelt_2022,
	title = {{RustHornBelt}: A Semantic Foundation for Functional Verification of Rust Programs with Unsafe Code},
	abstract = {Rust is a systems programming language that offers both lowlevel memory operations and high-level safety guarantees, via a strong ownership type system that prohibits mutation of aliased state. In prior work, Matsushita et al. developed {RustHorn}, a promising technique for functional verification of Rust code: it leverages the strong invariants of Rust types to express the behavior of stateful Rust code with first-order logic ({FOL}) formulas, whose verification is amenable to offthe-shelf automated techniques. {RustHorn}’s key idea is to use prophecies to describe the behavior of mutable borrows. However, the soundness of {RustHorn} was only established for a safe subset of Rust, and it has remained unclear how to extend it to support various safe {APIs} that encapsulate unsafe code (i.e., code where Rust’s aliasing discipline is relaxed).},
	pages = {16},
	journaltitle = {San Diego},
	author = {Matsushita, Yusuke and Denis, Xavier and Jourdan, Jacques-Henri and Dreyer, Derek},
	date = {2022},
	langid = {english},
	file = {Matsushita et al. - 2022 - RustHornBelt A Semantic Foundation for Functional.pdf:/home/csicar/Zotero/storage/S38GFT6S/Matsushita et al. - 2022 - RustHornBelt A Semantic Foundation for Functional.pdf:application/pdf},
}

@book{pierce_types_2002,
	location = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	pagetotal = {623},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002},
	langid = {english},
	keywords = {Programming languages (Electronic computers)},
	file = {Pierce - 2002 - Types and programming languages.pdf:/home/csicar/Zotero/storage/JUQL6P2M/Pierce - 2002 - Types and programming languages.pdf:application/pdf},
}

@book{pierce_types_2002-1,
	location = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	pagetotal = {623},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002},
	langid = {english},
	keywords = {Programming languages (Electronic computers)},
	file = {Pierce - 2002 - Types and programming languages.pdf:/home/csicar/Zotero/storage/QPZQ4MSZ/Pierce - 2002 - Types and programming languages.pdf:application/pdf},
}

@inproceedings{rondon_liquid_2008,
	location = {Tucson, {AZ}, {USA}},
	title = {Liquid types},
	isbn = {978-1-59593-860-2},
	url = {http://portal.acm.org/citation.cfm?doid=1375581.1375602},
	doi = {10.1145/1375581.1375602},
	eventtitle = {the 2008 {ACM} {SIGPLAN} conference},
	pages = {159},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation  - {PLDI} '08},
	publisher = {{ACM} Press},
	author = {Rondon, Patrick M. and Kawaguci, Ming and Jhala, Ranjit},
	urldate = {2022-06-30},
	date = {2008},
	langid = {english},
	file = {liquid_types.pdf:/home/csicar/Zotero/storage/IQLHNHZT/liquid_types.pdf:application/pdf},
}

@article{fouilhe_revisiting_nodate,
	title = {Revisiting the abstract domain of polyhedra: constraints-only representation and formal proof},
	pages = {153},
	author = {Fouilhe, Alexis},
	langid = {english},
	file = {Fouilhe - Revisiting the abstract domain of polyhedra const.pdf:/home/csicar/Zotero/storage/NVK6MIUN/Fouilhe - Revisiting the abstract domain of polyhedra const.pdf:application/pdf},
}

@article{singh_fast_2017,
	title = {Fast polyhedra abstract domain},
	volume = {52},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/3093333.3009885},
	doi = {10.1145/3093333.3009885},
	abstract = {Numerical abstract domains are an important ingredient of modern static analyzers used for verifying critical program properties (e.g., absence of buffer overflow or memory safety). Among the many numerical domains introduced over the years, Polyhedra is the most expressive one, but also the most expensive: it has worst-case exponential space and time complexity. As a consequence, static analysis with the Polyhedra domain is thought to be impractical when applied to large scale, real world programs. In this paper, we present a new approach and a complete implementation for speeding up Polyhedra domain analysis. Our approach does not lose precision, and for many practical cases, is orders of magnitude faster than state-of-the-art solutions. The key insight underlying our work is that polyhedra arising during analysis can usually be kept decomposed, thus considerably reducing the overall complexity. We first present the theory underlying our approach, which identifies the interaction between partitions of variables and domain operators. Based on the theory we develop new algorithms for these operators that work with decomposed polyhedra. We implemented these algorithms using the same interface as existing libraries, thus enabling static analyzers to use our implementation with little effort. In our evaluation, we analyze large benchmarks from the popular software verification competition, including Linux device drivers with over 50K lines of code. Our experimental results demonstrate massive gains in both space and time: we show end-to-end speedups of two to five orders of magnitude compared to state-of-the-art Polyhedra implementations as well as significant memory gains, on all larger benchmarks. In fact, in many cases our analysis terminates in seconds where prior code runs out of memory or times out after 4 hours. We believe this work is an important step in making the Polyhedra abstract domain both feasible and practically usable for handling large, real-world programs.},
	pages = {46--59},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Singh, Gagandeep and Püschel, Markus and Vechev, Martin},
	urldate = {2022-07-13},
	date = {2017-01-01},
	keywords = {Abstract interpretation, Numerical program analysis, Partitions, Performance optimization, Polyhedra decomposition},
}

@article{singh_fast_nodate,
	title = {Fast Polyhedra Abstract Domain},
	abstract = {Numerical abstract domains are an important ingredient of modern static analyzers used for verifying critical program properties (e.g., absence of buffer overﬂow or memory safety). Among the many numerical domains introduced over the years, Polyhedra is the most expressive one, but also the most expensive: it has worst-case exponential space and time complexity. As a consequence, static analysis with the Polyhedra domain is thought to be impractical when applied to large scale, real world programs.},
	pages = {14},
	author = {Singh, Gagandeep and Püschel, Markus and Vechev, Martin},
	langid = {english},
	file = {Singh et al. - Fast Polyhedra Abstract Domain.pdf:/home/csicar/Zotero/storage/R548YWGI/Singh et al. - Fast Polyhedra Abstract Domain.pdf:application/pdf},
}

@article{puschel_fast_nodate,
	title = {Fast Polyhedra Abstract Domain},
	pages = {75},
	author = {Püschel, Gagandeep Singh Markus and Vechev, Martin},
	langid = {english},
	file = {Püschel und Vechev - Fast Polyhedra Abstract Domain.pdf:/home/csicar/Zotero/storage/PGPVADME/Püschel und Vechev - Fast Polyhedra Abstract Domain.pdf:application/pdf},
}

@incollection{ramalingam_sound_2008,
	location = {Berlin, Heidelberg},
	title = {A Sound Floating-Point Polyhedra Abstract Domain},
	volume = {5356},
	isbn = {978-3-540-89329-5 978-3-540-89330-1},
	url = {http://link.springer.com/10.1007/978-3-540-89330-1_2},
	abstract = {The polyhedra abstract domain is one of the most powerful and commonly used numerical abstract domains in the ﬁeld of static program analysis based on abstract interpretation. In this paper, we present an implementation of the polyhedra domain using ﬂoating-point arithmetic without sacriﬁcing soundness. Floating-point arithmetic allows a compact memory representation and an eﬃcient implementation on current hardware, at the cost of some loss of precision due to rounding. Our domain is based on a constraint-only representation and employs sound ﬂoating-point variants of Fourier-Motzkin elimination and linear programming. The preliminary experimental results of our prototype are encouraging. To our knowledge, this is the ﬁrst time that the polyhedra domain is adapted to ﬂoating-point arithmetic in a sound way.},
	pages = {3--18},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Chen, Liqian and Miné, Antoine and Cousot, Patrick},
	editor = {Ramalingam, G.},
	urldate = {2022-07-13},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-89330-1_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Chen et al. - 2008 - A Sound Floating-Point Polyhedra Abstract Domain.pdf:/home/csicar/Zotero/storage/VM5WRSYB/Chen et al. - 2008 - A Sound Floating-Point Polyhedra Abstract Domain.pdf:application/pdf},
}

@misc{lehmann_flux_2022,
	title = {Flux: Liquid Types for Rust},
	url = {http://arxiv.org/abs/2207.04034},
	shorttitle = {Flux},
	abstract = {Low-level pointer-manipulating programs are hard to verify, requiring complex spatial program logics that support reasoning about aliasing and separation. Worse, when working over collections, these logics burden the programmer with annotating loops with quantified invariants that describe the contents of the collection. We present Flux, which shows how logical refinements can work hand in glove with Rust's ownership mechanisms to yield ergonomic type-based verification for low-level imperative code. To do so Flux indexes mutable locations, with pure (immutable) values that can appear in the refinements, and then exploits Rust's ownership mechanisms to abstract sub-structural reasoning about locations within Rust's polymorphic type constructors, extended by a notion of strong references to idiomatically track strong updates. By factoring complex invariants into type constructors and simple refinements, Flux can efficiently synthesize loop annotations via liquid inference. We use a suite of vector-manipulating programs to demonstrate the advantages of Flux's refinement types over program logics, as implemented in the state-of-the-art Prusti verifier. We show that liquid typing makes verification ergonomic by slashing specification lines by a factor of two, verification time by an order of magnitude, and invariant annotation overhead from 14\% of code size, to nothing at all.},
	number = {{arXiv}:2207.04034},
	publisher = {{arXiv}},
	author = {Lehmann, Nico and Geller, Adam and Barthe, Gilles and Vazou, Niki and Jhala, Ranjit},
	urldate = {2022-07-14},
	date = {2022-07-08},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2207.04034 [cs]},
	note = {Number: {arXiv}:2207.04034},
	keywords = {Computer Science - Programming Languages, D.2.4, F.3.1},
	file = {Lehmann et al. - 2022 - Flux Liquid Types for Rust.pdf:/home/csicar/Zotero/storage/PEE6XE5M/Lehmann et al. - 2022 - Flux Liquid Types for Rust.pdf:application/pdf},
}

@book{pierce_types_2002-2,
	location = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	pagetotal = {623},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002},
	langid = {english},
	keywords = {Programming languages (Electronic computers)},
	file = {Pierce - 2002 - Types and programming languages.pdf:/home/csicar/Zotero/storage/J5Z9XND3/Pierce - 2002 - Types and programming languages.pdf:application/pdf},
}

@inproceedings{wadler_theorems_1989,
	location = {New York, {NY}, {USA}},
	title = {Theorems for free!},
	isbn = {978-0-89791-328-7},
	url = {https://doi.org/10.1145/99370.99404},
	doi = {10.1145/99370.99404},
	series = {{FPCA} '89},
	pages = {347--359},
	booktitle = {Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	publisher = {Association for Computing Machinery},
	author = {Wadler, Philip},
	urldate = {2022-08-29},
	date = {1989-11-01},
	file = {Full Text PDF:/home/csicar/Zotero/storage/BJCCZB9T/Wadler - 1989 - Theorems for free!.pdf:application/pdf},
}

@book{pierce_types_2002-3,
	title = {Types and Programming Languages},
	isbn = {978-0-262-16209-8},
	abstract = {A comprehensive introduction to type systems and programming languages.A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems—and of programming languages from a type-theoretic perspective—has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.},
	pagetotal = {656},
	publisher = {{MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002-01-04},
	langid = {english},
	note = {Google-Books-{ID}: ti6zoAC9Ph8C},
	keywords = {Computers / Languages / General},
	file = {Pierce - 2002 - Types and Programming Languages.pdf:/home/csicar/Zotero/storage/IYSAZ4VI/Pierce - 2002 - Types and Programming Languages.pdf:application/pdf},
}