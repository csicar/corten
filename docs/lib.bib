
@article{erdin_verication_nodate,
	title = {Veriﬁcation of Rust Generics, Typestates, and Traits},
	pages = {75},
	author = {Erdin, Matthias},
	langid = {english},
	file = {Erdin - Veriﬁcation of Rust Generics, Typestates, and Trai.pdf:/home/csicar/Zotero/storage/UIQXBPV7/Erdin - Veriﬁcation of Rust Generics, Typestates, and Trai.pdf:application/pdf},
}

@thesis{denis_creusot_2021,
	title = {The Creusot Environment for the Deductive Verification of Rust Programs},
	institution = {Inria Saclay-Île de France},
	type = {phdthesis},
	author = {Denis, Xavier and Jourdan, Jacques-Henri and Marché, Claude},
	date = {2021},
	file = {Full Text:/home/csicar/Zotero/storage/IQIUWIZQ/Denis et al. - 2021 - The Creusot Environment for the Deductive Verifica.pdf:application/pdf;Snapshot:/home/csicar/Zotero/storage/K7HUXUK5/hal-03526634.html:text/html},
}

@inproceedings{matsushita_rusthorn_2020,
	title = {{RustHorn}: {CHC}-based verification for Rust programs},
	shorttitle = {{RustHorn}},
	pages = {484--514},
	booktitle = {European Symposium on Programming},
	publisher = {Springer, Cham},
	author = {Matsushita, Yusuke and Tsukada, Takeshi and Kobayashi, Naoki},
	date = {2020},
	file = {Full Text:/home/csicar/Zotero/storage/IV87RRRX/Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:application/pdf;Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:/home/csicar/Zotero/storage/TW2TN794/Matsushita et al. - 2020 - RustHorn CHC-based verification for Rust programs.pdf:application/pdf},
}

@article{beckmann_verifying_2020,
	title = {Verifying Safe Clients of Unsafe Code and Trait Implementations in Rust},
	author = {Beckmann, Jakob},
	date = {2020},
	file = {Full Text:/home/csicar/Zotero/storage/7W24IZJG/Beckmann - 2020 - Verifying Safe Clients of Unsafe Code and Trait Im.pdf:application/pdf},
}

@article{reed_patina_2015,
	title = {Patina: A formalization of the Rust programming language},
	shorttitle = {Patina},
	pages = {264},
	journaltitle = {University of Washington, Department of Computer Science and Engineering, Tech. Rep. {UW}-{CSE}-15-03-02},
	author = {Reed, Eric},
	date = {2015},
	file = {Full Text:/home/csicar/Zotero/storage/5ZNMKC3P/Reed - 2015 - Patina A formalization of the Rust programming la.pdf:application/pdf},
}

@article{gordon_rely-guarantee_nodate,
	title = {Rely-Guarantee References for Reﬁnement Types Over Aliased Mutable Data (Extended Version ∗)},
	abstract = {Reasoning about side effects and aliasing is the heart of verifying imperative programs. Unrestricted side effects through one reference can invalidate assumptions about an alias. We present a new type system approach to reasoning about safe assumptions in the presence of aliasing and side effects, unifying ideas from reference immutability type systems and rely-guarantee program logics. Our approach, rely-guarantee references, treats multiple references to shared objects similarly to multiple threads in rely-guarantee program logics. We propose statically associating rely and guarantee conditions with individual references to shared objects. Multiple aliases to a given object may coexist only if the guarantee condition of each alias implies the rely condition for all other aliases. We demonstrate that existing reference immutability type systems are special cases of rely-guarantee references.},
	pages = {21},
	author = {Gordon, Colin S and Ernst, Michael D and Grossman, Dan},
	langid = {english},
	file = {Gordon et al. - Rely-Guarantee References for Reﬁnement Types Over.pdf:/home/csicar/Zotero/storage/8XFSDE5Z/Gordon et al. - Rely-Guarantee References for Reﬁnement Types Over.pdf:application/pdf},
}

@inproceedings{sato_combining_2019,
	location = {Cascais, Portugal},
	title = {Combining higher-order model checking with refinement type inference},
	isbn = {978-1-4503-6226-9},
	url = {http://dl.acm.org/citation.cfm?doid=3294032.3294081},
	doi = {10.1145/3294032.3294081},
	abstract = {There have been two major approaches to fully automated verification of higher-order functional programs: higherorder model checking and refinement type inference. The former approach is precise, but suffers from a bottleneck in the predicate discovery phase. The latter approach is generally faster than the former, thanks to the recent advances in constrained Horn clause ({CHC}) solving, but is imprecise, in that it rejects some valid programs. To take the best of the two approaches, we refine the higher-order model checking approach, by employing {CHC} solving in the predicate discovery phase. We have implemented the new approach and confirmed that the new system can verify more programs than those based on the previous two approaches.},
	eventtitle = {the 2019 {ACM} {SIGPLAN} Workshop},
	pages = {47--53},
	booktitle = {Proceedings of the 2019 {ACM} {SIGPLAN} Workshop on Partial Evaluation and Program Manipulation  - {PEPM} 2019},
	publisher = {{ACM} Press},
	author = {Sato, Ryosuke and Iwayama, Naoki and Kobayashi, Naoki},
	urldate = {2022-01-27},
	date = {2019},
	langid = {english},
	file = {Sato et al. - 2019 - Combining higher-order model checking with refinem.pdf:/home/csicar/Zotero/storage/23RTH8SA/Sato et al. - 2019 - Combining higher-order model checking with refinem.pdf:application/pdf},
}

@inproceedings{oconnor_refinement_2016,
	location = {Nara Japan},
	title = {Refinement through restraint: bringing down the cost of verification},
	isbn = {978-1-4503-4219-3},
	url = {https://dl.acm.org/doi/10.1145/2951913.2951940},
	doi = {10.1145/2951913.2951940},
	shorttitle = {Refinement through restraint},
	abstract = {We present a framework aimed at signiﬁcantly reducing the cost of verifying certain classes of systems software, such as ﬁle systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for eﬃcient C code generation; and one functional, suitable for equational reasoning and veriﬁcation. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C veriﬁcation frameworks.},
	eventtitle = {{ICFP}'16: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {89--102},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {O'Connor, Liam and Chen, Zilin and Rizkallah, Christine and Amani, Sidney and Lim, Japheth and Murray, Toby and Nagashima, Yutaka and Sewell, Thomas and Klein, Gerwin},
	urldate = {2022-01-27},
	date = {2016-09-04},
	langid = {english},
	file = {O'Connor et al. - 2016 - Refinement through restraint bringing down the co.pdf:/home/csicar/Zotero/storage/VGLKJBTZ/O'Connor et al. - 2016 - Refinement through restraint bringing down the co.pdf:application/pdf},
}

@article{weiss_oxide_2021,
	title = {Oxide: The Essence of Rust},
	url = {http://arxiv.org/abs/1903.00982},
	shorttitle = {Oxide},
	abstract = {Rust claims to advance industrial programming by bridging the gap between low-level systems programming and high-level application programming. At the heart of the argument that this enables programmers to build more reliable and efficient software is the borrow checker - a novel approach to ownership that aims to balance type system expressivity with usability. And yet, to date there is no core type system that captures Rust's notion of ownership and borrowing, and hence no foundation for research on Rust to build upon. In this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. We present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as an approximation of the provenances of references, and our type system is able to automatically compute this information through a substructural typing judgment. We provide the first syntactic proof of type safety for borrow checking using progress and preservation. Oxide is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.},
	journaltitle = {{arXiv}:1903.00982 [cs]},
	author = {Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Ahmed, Amal},
	urldate = {2022-01-27},
	date = {2021-10-19},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1903.00982},
	keywords = {Computer Science - Programming Languages},
	file = {Weiss et al. - 2021 - Oxide The Essence of Rust.pdf:/home/csicar/Zotero/storage/GEWQA5M8/Weiss et al. - 2021 - Oxide The Essence of Rust.pdf:application/pdf},
}

@article{kloos_asynchronous_2015,
	title = {Asynchronous Liquid Separation Types},
	url = {http://drops.dagstuhl.de/opus/volltexte/2015/5223/},
	doi = {10.4230/LIPICS.ECOOP.2015.396},
	abstract = {We present a reﬁnement type system for reasoning about asynchronous programs manipulating shared mutable state. Our type system guarantees the absence of races and the preservation of user-speciﬁed invariants using a combination of two ideas: reﬁnement types and concurrent separation logic. Our type system allows precise reasoning about programs using two ingredients. First, our types are indexed by sets of resource names and the type system tracks the eﬀect of program execution on individual heap locations and task handles. In particular, it allows making strong updates to the types of heap locations. Second, our types track ownership of shared state across concurrently posted tasks and allow reasoning about ownership transfer between tasks using permissions. We demonstrate through several examples that these two ingredients, on top of the framework of liquid types, are powerful enough to reason about correct behavior of practical, complex, asynchronous systems manipulating shared heap resources.},
	pages = {25 pages},
	author = {Kloos, Johannes and Majumdar, Rupak and Vafeiadis, Viktor},
	editora = {Herbstritt, Marc},
	editoratype = {collaborator},
	urldate = {2022-01-27},
	date = {2015},
	langid = {english},
	note = {Artwork Size: 25 pages
Medium: application/pdf
Publisher: Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik {GmbH}, Wadern/Saarbruecken, Germany},
	keywords = {000 Computer science, knowledge, general works, Computer Science},
	file = {Kloos et al. - 2015 - Asynchronous Liquid Separation Types.pdf:/home/csicar/Zotero/storage/WAE34UL7/Kloos et al. - 2015 - Asynchronous Liquid Separation Types.pdf:application/pdf},
}

@article{jung_rustbelt_2018,
	title = {{RustBelt}: securing the foundations of the Rust programming language},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3158154},
	doi = {10.1145/3158154},
	shorttitle = {{RustBelt}},
	abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
	pages = {1--34},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
	urldate = {2022-02-17},
	date = {2018-01},
	langid = {english},
	file = {Jung et al. - 2018 - RustBelt securing the foundations of the Rust pro.pdf:/home/csicar/Zotero/storage/8PK9HFSL/Jung et al. - 2018 - RustBelt securing the foundations of the Rust pro.pdf:application/pdf},
}