\documentclass{article}
\usepackage{bussproofs}
\usepackage{ amssymb }
\usepackage{xargs}
\usepackage{xcolor}
\usepackage{ amsmath }
\usepackage[utf8]{inputenc}
\usepackage{draculatheme}


\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\tableofcontents

\section{The Case for Rust as a Target Language}

Rust is split into two languages: safe and unsafe Rust. Like most type systems, Rust's type and ownership system is conservative, meaning any (safe) Rust program that type checks, will not crash due to memory safety or type errors. Unsafe Rust gives the programmer the ability to expand the programs accepted by Rust. 

In this thesis, we will only consider safe Rust, which is the subset of Rust most programmers interact with (See \ref{ss:unsafe-rust}).

\paragraph{Aliasing XOR Mutabillity} The key behind Rusts type system is, that for every variable at every point during the execution, that variable is either aliased or mutable, but never both at the same time. 

Rust accomplished this by introducing three types of access permissions for a variable, which are associated with every scope\footnote{In modern Rust, this model was generalized to cover more cases, but the idea is still valid}:
\begin{enumerate}
  \item The scope \textit{owns} the variable. This guarantees, that no other scope has access to any part of the variable and allows the scope to create references to (part of) the variable. 
  \item The scope (immutably) \textit{borrows} the variable. This guarantees, that as long as the variable is used, its \textit{value will not change} and allows the scope to further lend the variable to other scoped.
  \item The scope \textit{mutably borrows} the variable. This guarantees, that there are no other active references to any part of the memory of the variable. 
\end{enumerate}

A consequence of these rules it, that at any time, every piece of memory has a unique and compile-time known owner. There are no reference cycles.

This makes both aliasing as well as mutability quite tame:
If a variable is aliased, it must be immutable and as a result, represents just a value (like in pure functional languages).
If a variable is mutable, it can not be aliased and as a result, any effect of the mutation is well known and locally visible.

\section{Usage Of Rust}

\label{ss:unsafe-rust}\subsection{Unsafe Rust}

\section{Definitions}

\paragraph*{$P$} is the set of program variables used in rust program. Common names $a, b, c$
\paragraph*{$L$} is the set of logic variables used in refinement types. Common names: $\alpha, \beta$

\paragraph*{$\Gamma = (\mu, \sigma)$} is a tuple containing a function $\mu: P \to L$ mapping all program variables to their (current) logic variable and a set of formulas $\sigma$ over $L$. During execution of statements, the set increases monotonically

\paragraph*{$\tau$} is a user defined type $\{ \alpha : b \mid \varphi\}$. Where $\alpha$ is a logic variable from $L$, $b$ is a base type from Rust (like \texttt{i32}) and $\varphi$ is a formula over variables in $L$.

\section{Typing Rules}

\paragraph*{Abbreviations}
We write:
\begin{itemize}
  \item  $\Gamma, c$ for $(\mu, \sigma \wedge c)$
  \item $\Gamma[a \mapsto \alpha]$ for $(\mu[a \mapsto \alpha], \sigma)$
\end{itemize}


\subsection{Expression Typing: $\Gamma \vdash e : \tau$}

\begin{prooftree}
  \AxiomC{$l \text{ fresh}$}
  \AxiomC{$\text{base\_ty}(v) = b$}
  \LeftLabel{$\text{LIT}$}
  \BinaryInfC{$\Gamma \vdash v: \{ l : b \mid l \doteq v\} \Rightarrow \Gamma$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\beta \text{ fresh}$}
  \AxiomC{$\mu(x) = \beta$}
  \LeftLabel{$\text{VAR}$}
  \BinaryInfC{$\Gamma = (\mu, \sigma)\vdash x : \{ \alpha : b \mid \beta \doteq \alpha \} \Rightarrow \Gamma$}
\end{prooftree}



\begin{prooftree}
  \AxiomC{$\Gamma \vdash y : \tau $}
  \AxiomC{$\Gamma \vdash x : \{ \beta : \&b \mid \beta \doteq \&y \}$}
  \LeftLabel{$\text{VAR-REF}$}
  \BinaryInfC{$\Gamma \vdash *x : \tau \Rightarrow \Gamma$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash c : \text{bool} \Rightarrow \Gamma_c$}
  \AxiomC{$\Gamma_c, c \vdash c_t : \tau \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma_c, \neg c \vdash c_e : \tau \Rightarrow \Gamma'$}
  \LeftLabel{$\text{IF}$}
  \TrinaryInfC{$\Gamma \vdash \text{if } c \text{ then }c_t\text{ else } c_e : \tau \Rightarrow \Gamma'$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma_I, c \vdash s \Rightarrow \Gamma_I' $}
  \AxiomC{$\Gamma_I' \preceq \Gamma_I$}
  \LeftLabel{$\text{WHILE}$}
  \BinaryInfC{$\Gamma_I \vdash \texttt{while}(c) s \Rightarrow \Gamma_I,\neg c$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash s_1 : \tau_1 \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma' \vdash \bar s : \tau \Rightarrow \Gamma''$}
  \LeftLabel{$\text{SEQ}$}
  \BinaryInfC{$\Gamma \vdash s_1 ; \bar s : \tau \Rightarrow \Gamma''$}
\end{prooftree}



\begin{prooftree}
  \AxiomC{$\Gamma \vdash e_1 : \{v_1:b \mid \varphi_1\} \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma' \vdash e_2 : \{v_2:b \mid \varphi_2\} \Rightarrow \Gamma''$}
  \LeftLabel{$\text{ADD}$}
  \BinaryInfC{$\Gamma \vdash e_1 + e_2 : \{ v: b \mid v \doteq [e_1] + [e_2]\} \Rightarrow \Gamma'', \varphi_1, \varphi_2$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \{ \beta \mid \varphi \} \Rightarrow \Gamma'$}
  \LeftLabel{$\text{ASSIGN}$}
  \UnaryInfC{$\Gamma \vdash x = e : \tau \Rightarrow \Gamma' [x \mapsto \beta], \varphi$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \{ \beta \mid \varphi \} \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma \vdash x: \{ \alpha : \& b \mid \alpha \doteq \&y\}$}
  \LeftLabel{$\text{ASSIGN-STRONG}$}
  \BinaryInfC{$\Gamma \vdash *x = e : \tau \Rightarrow \Gamma' [y \mapsto \beta], \varphi$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \tau \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma \vdash x: \{ \alpha : \& b \mid \alpha \doteq \&y \vee \alpha \doteq \&z \vee \dots\}$}
  \AxiomC{$\Gamma \vdash \tau \preceq \tau_y$}
  \AxiomC{$\Gamma \vdash y : \tau_y$}
  \LeftLabel{$\text{ASSIGN-WEAK}$}
  \QuaternaryInfC{$\Gamma \vdash *x = e : \tau \Rightarrow \Gamma'$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$ (\{a \mapsto \tau_a, \dots\}, \{\alpha \doteq \mu(a), \dots, \varphi_{\alpha}, \dots\}) \preceq \Gamma$}
  \AxiomC{$f : (\{ \alpha \mid \varphi_{\alpha} \} \Rightarrow \{ \alpha' \mid \varphi'_{\alpha} \}, \dots)$}
  \LeftLabel{$\text{FN-CALL}$}
  \BinaryInfC{$\Gamma \vdash f(a, \dots)  \Rightarrow (\mu[a \mapsto \alpha', \dots], \sigma \wedge \varphi'_{\alpha} \wedge \dots)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \tau$}
  \AxiomC{$\Gamma \vdash \tau \preceq \tau'$}
  \LeftLabel{$\text{INTRO-SUB}$}
  \BinaryInfC{$\Gamma \vdash e \texttt{ as } \tau': \tau'$}
\end{prooftree}

\subsection{Sub-Typing Rules: $\Gamma \vdash \tau \preceq \tau'$}

\begin{prooftree}
  \AxiomC{$\sigma \wedge \varphi'[\beta \triangleright \alpha ] \vDash \varphi$}
  \LeftLabel{$\text{$\preceq$-TY}$}
  \UnaryInfC{$\Gamma = (\mu, \sigma) \vdash \{ \alpha \mid \varphi\} \preceq \{ \beta \mid \varphi' \}$}
\end{prooftree}

alternative (should be equivalent):

\begin{prooftree}
  \AxiomC{$\Gamma[f \mapsto \alpha], \varphi \preceq \Gamma[f \mapsto \beta], \varphi'$}
  \AxiomC{$f \text{ fresh}$}
  \LeftLabel{$\text{$\preceq$-TY-ALT}$}
  \BinaryInfC{$\Gamma \vdash \{ \alpha \mid \varphi\} \preceq \{ \beta \mid \varphi' \}$}
\end{prooftree}


\subsection{Sub-Context Rules: $\Gamma \preceq \Gamma'$}


\begin{prooftree}
  \AxiomC{$\sigma'[\mu(\alpha) \triangleright \mu'(\alpha)\ \mid \alpha \in dom(\mu)] \vDash \sigma$}
  \AxiomC{$dom(\mu) \subseteq dom(\mu')$}
  \LeftLabel{$\text{$\preceq$-CTX}$}
  \BinaryInfC{$(\sigma, \mu) \preceq (\sigma', \mu')$}
\end{prooftree}

\end{document}