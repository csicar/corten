\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{ bussproofs }
\usepackage{ amssymb }
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xargs}
\usepackage{simplebnf}
\usepackage{xcolor}
\usepackage{ amsmath }
\usepackage{amsthm}
\usepackage{csquotes}
\usepackage[british]{babel}

\usepackage[bibstyle=numeric, backend=bibtex, sorting=none]{biblatex}
\addbibresource{../Meine Bibliothek.bib}

\usepackage{draculatheme}


\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\mtext}[1]{$\text{#1}$}


\newcommand{\ccolon}[0]{: }
\newcommand{\cmid}[0]{| }
\newcommand{\cdisj}[0]{|| }


\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\begin{document}

\tableofcontents

\section{Introduction}

\section{The Case for Rust as a Target Language}

Rust is split into two languages: safe and unsafe Rust. Like most type systems, Rust's type and ownership system is conservative, meaning any (safe) Rust program that type checks, will not crash due to memory safety or type errors. Unsafe Rust gives the programmer the ability to expand the programs accepted by Rust outside that known-safe subset.

In this thesis, we will only consider safe Rust, which is the subset of Rust most programmers interact with (see section \ref{ss:unsafe-rust}).

Rust features a few unusual design decisions that profoundly influence the design of verification systems for it. The following paragraphs will elaborate on this.

\paragraph{Aliasing XOR Mutabillity} The key behind Rusts type system is, that for every variable at every point during the execution, that variable is either aliased or mutable, but never both at the same time. 

Rust accomplished this by introducing three types of access permissions for a variable, which are associated with every scope\footnote{In modern Rust, this model was generalized to cover more cases, but the idea is still valid}:
\begin{enumerate}
  \item The scope \textit{owns} the variable. This guarantees, that no other scope has access to any part of the variable and allows the scope to create references to (part of) the variable. 
  \item The scope (immutably) \textit{borrows} the variable. This guarantees, that as long as the variable is used, its \textit{value will not change} and allows the scope to further lend the variable to other scoped.
  \item The scope \textit{mutably borrows} the variable. This guarantees, that there are no other active references to any part of the memory of the variable. 
\end{enumerate}

A consequence of these rules it, that at any time, every piece of memory has a unique and compile-time known owner. There are no reference cycles.

This makes both aliasing as well as mutability quite tame:
If a variable is aliased, it must be immutable and as a result, represents just a value (like in pure functional languages).
If a variable is mutable, it can not be aliased and as a result, any effect of the mutation is well known and locally visible.

\paragraph*{Opaque Generics} Rust does not provide a way to check a generic parameter for its instantiation. This means that we cannot extract any additional information from a generic parameter \code{T}. A function from \code{T} to \code{T} can therefor only be the identity function.
Wadler \cite{wadler_theorems_1989} shows, that it is possible to derive facts about the behaviour of such polymorphic functions.

In contrast, languages with instance-of-checks allow an implementation of a polymorphic function to distinguish between different instances of the generic parameter, precluding this extensive reasoning.

\paragraph*{Explicit Mutable Access} A consequence of the ownership rules is, that a function can only mutate (part of) the state, that is passed to it as a parameter. There is no global state and there is no implicit access to an object instance. Thus any intention of mutating state must already be expressed in the function signature, which makes the specification of this mutation quite natural.

\paragraph*{What Rust does not solve} Eventhough Rust siplifies reasoning about mutability and aliasing of mutable data, Rust does not eliminate the need to reason about multiple references to mutable data. For example, Listing \ref{lst:alias-mut} shows how \code{cell}'s type is influenced by changes to \code{r}. This does not mean, that the ownership rule  \textit{mutability XOR aliasing} are broken: Eventhough both \code{cell} and \code{r} are mutable, but only one is active.

\label{lst:alias-mut}\begin{lstlisting}
let mut cell = 2;
let r = &mut cell;
r+= 1;
assert(cell, 2)
\end{lstlisting}

\section{Usage Of Rust}

\label{ss:unsafe-rust}\subsection{Unsafe Rust}

\section{The MiniCorten Language}

Rust's main disadvantage as a target language it its size: There is a lot of syntax and semantics that would need to be accounted. A lot of it even incidental to the verification. To reduce the complexity and amount of work, that needs to be done, we will focus on a subset of Rust described in this section.

The goal is to remove as much incidental complexity as possible without compromising to the central topic of research: How to extend LiquidTypes to mutability under the presence of Rust's ownership model.

\subsection{Syntax}

\todo{Call it CortenRust (after Weathering Steel)}
This subsection will introduce the syntax of MiniCorten, a language modelled after a simplified version of Rust, with the addition of refinement types.

\begin{bnfgrammar}
  $program$ ::=
    $func\_decl$ * : function declaration
  ;;
  $func\_decl$ ::=
    $ident$( $param$ * ) -> $ty$ \{ $stmt$ \}
  ;;
  $param$ ::= $ident$ \ccolon  $ty$
  ;;
  $stmt$ ::= 
    $expr$                                                : expression
    | let mut? $ident$ = $expr$                           : declaration
    | $ident$ = $expr$                                    : assignment
    | while ($expr$) \{ $stmt$ \}                         : while loop
    | relax\_ctx!\{ $pred$* ; ($ident$ \ccolon $ty$)* \}  : context relaxation
  ;;
  $expr$ ::=
    $ident$                                         : variable reference
    | $lit$                                         : constant
    | $expr$ + $expr$                               : addition
    | $ident$($ident$ *)                            : function call
    | if $expr$ \{ $stmt$ \} else \{ $stmt$ \}      : if expression
    | $stmt$; $expr$                                : sequence
    | * $ident$                                     : dereference
    | \& $ident$                                    : immutable reference
    | \&mut $ident$                                 : mutable reference
    | $expr$ as $ty$                                : type relaxation
  ;;
  $ty$ ::= ty!\{ $logic\_ident$ \ccolon $base\_ty$ \cmid $pred$ \} : refinement type
  ;;
  $pred$ ::=
    $ref\_pred$                                     : predicate for a reference type 
    | $value\_pred$                                 : predicate for a value type
  ;;
  $ref\_pred$ ::=
    $logic\_ident$ = \& $ident$
    | $ref\_pred$ \cdisj $ref\_pred$         : mutable reference 
  ;;
  $value\_pred$ ::=
    $logic\_ident$                : variable
  | $pred$ \&\& $pred$            : conjunction
  | $pred$ \cdisj $pred$          : disjunction
  | ! $pred$                      : negation
  $base\_ty$ ::=
    i32                     : integer
    | unit                  : unit type
    | bool                  : boolean
    | \& $base\_ty$         : immutable reference
    | \&mut $base\_ty$      : mutable reference
  ;;
  $lit$ ::=
      0,1,...,n             : integer
    | true                  : boolean true
    | false                 : boolean false
    | ()                    : unit value
\end{bnfgrammar}

\subsection{Semantics}

The semantics are mostly standard. The main difference being that Rust and our simplified language enable most statements to be used in place of an expression. The value is determined by the last statement in the sequence. For example If-Expressions, sequences of statements and function all follow this rule: Their (return) value is determined by the last statement or expression in the sequence.

The semantics loosely based on Jung's MiniRust.

Another difference between Rust and MiniCorten is of course the addition of refinement types. 

In terms of the formal description, the rules are similar to Pierce's \cite[p. 166f]{pierce_types_2002-3} Reference language. The main difference is, that in Rust, every piece of data has a unique, known owner. This fact makes the concept of locations redundant. Instead we treat $\code{ref } x$ as a value itself. The following definitions show the new execution rules.

\begin{definition}[Execution-State]
  The state of execution is given by $\mu : \text{PVar} \to \text{Value}$. The set of function declarations is constant and given by $\Sigma : \text{Fn-Name} \to ((\text{Arg}_1, \dots, \text{Arg}_n), \text(ReturnValue))$
\end{definition}

\begin{definition}[Small-Step Semantics of MiniCorten: $t \mid \mu \leadsto t' \mid \mu'$]
  

  \begin{prooftree}
    \AxiomC{$\star$}
    \LeftLabel{\mtext{SS-Assign}}
    \UnaryInfC{$x = v \mid \mu \leadsto \code{unit} \mid \mu[x \mapsto v]$}
  \end{prooftree}


  \begin{prooftree}
    \AxiomC{$\mu(x) = v$}
    \LeftLabel{\mtext{SS-Deref}}
    \UnaryInfC{$* \code{ref } x \mid \mu \leadsto v \mid \mu$}
  \end{prooftree}


  \begin{prooftree}
    \AxiomC{$t \mid \mu \leadsto t' \mid \mu'$}
    \LeftLabel{\mtext{SS-Deref-Inner}}
    \UnaryInfC{$* t \mid \mu \leadsto * t' \mid \mu'$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$t \mid \mu \leadsto t' \mid \mu'$}
    \LeftLabel{\mtext{SS-Ref-Inner}}
    \UnaryInfC{$\code{ref } t \mid \mu \leadsto \code{ref } t' \mid \mu'$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$t \mid \mu \leadsto t' \mid \mu'$}
    \LeftLabel{\mtext{SS-Assign-Inner}}
    \UnaryInfC{$x = t \mid \mu \leadsto x = t' \mid \mu'$}
  \end{prooftree}

\end{definition}

\section{The Refinement Type System}

\subsection{Definitions}

\paragraph*{$P$} is the set of program variables used in rust program. Common names $a, b, c$
\paragraph*{$L$} is the set of logic variables used in refinement types. Common names: $\alpha, \beta$

\paragraph*{$\Gamma = (\mu, \sigma)$} is a tuple containing a function $\mu: P \to L$ mapping all program variables to their (current) logic variable and a set of formulas $\sigma$ over $L$. During execution of statements, the set increases monotonically

\paragraph*{$\tau$} is a user defined type $\{ \alpha : b \mid \varphi\}$. Where $\alpha$ is a logic variable from $L$, $b$ is a base type from Rust (like \texttt{i32}) and $\varphi$ is a formula over variables in $L$.

\paragraph*{Abbreviations}
We write:
\begin{itemize}
  \item  $\Gamma, c$ for $(\mu, \sigma \wedge c)$
  \item $\Gamma[a \mapsto \alpha]$ for $(\mu[a \mapsto \alpha], \sigma)$
\end{itemize}


\subsection{Expression Typing: $\Gamma \vdash e : \tau$}

\begin{prooftree}
  \AxiomC{$l \text{ fresh}$}
  \AxiomC{$\text{base\_ty}(v) = b$}
  \LeftLabel{$\text{LIT}$}
  \BinaryInfC{$\Gamma \vdash v: \{ l : b \mid l \doteq v\} \Rightarrow \Gamma$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\beta \text{ fresh}$}
  \AxiomC{$\mu(x) = \beta$}
  \LeftLabel{$\text{VAR}$}
  \BinaryInfC{$\Gamma = (\mu, \sigma)\vdash x : \{ \alpha : b \mid \beta \doteq \alpha \} \Rightarrow \Gamma$}
\end{prooftree}



\begin{prooftree}
  \AxiomC{$\Gamma \vdash y : \tau $}
  \AxiomC{$\Gamma \vdash x : \{ \beta : \&b \mid \beta \doteq \&y \}$}
  \LeftLabel{$\text{VAR-REF}$}
  \BinaryInfC{$\Gamma \vdash *x : \tau \Rightarrow \Gamma$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash c : \text{bool} \Rightarrow \Gamma_c$}
  \AxiomC{$\Gamma_c, c \vdash c_t : \tau \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma_c, \neg c \vdash c_e : \tau \Rightarrow \Gamma'$}
  \LeftLabel{$\text{IF}$}
  \TrinaryInfC{$\Gamma \vdash \text{if } c \text{ then }c_t\text{ else } c_e : \tau \Rightarrow \Gamma'$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma_I, c \vdash s \Rightarrow \Gamma_I' $}
  \AxiomC{$\Gamma_I',c \preceq \Gamma_I$}
  \LeftLabel{$\text{WHILE}$}
  \BinaryInfC{$\Gamma_I \vdash \texttt{while}(c) s \Rightarrow \Gamma_I,\neg c$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash s_1 : \tau_1 \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma' \vdash \bar s : \tau \Rightarrow \Gamma''$}
  \LeftLabel{$\text{SEQ}$}
  \BinaryInfC{$\Gamma \vdash s_1 ; \bar s : \tau \Rightarrow \Gamma''$}
\end{prooftree}



\begin{prooftree}
  \AxiomC{$\Gamma \vdash e_1 : \{v_1:b \mid \varphi_1\} \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma' \vdash e_2 : \{v_2:b \mid \varphi_2\} \Rightarrow \Gamma''$}
  \LeftLabel{$\text{ADD}$}
  \BinaryInfC{$\Gamma \vdash e_1 + e_2 : \{ v: b \mid v \doteq [e_1] + [e_2]\} \Rightarrow \Gamma'', \varphi_1, \varphi_2$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \{ \beta \mid \varphi \} \Rightarrow \Gamma'$}
  \LeftLabel{$\text{ASSIGN}$}
  \UnaryInfC{$\Gamma \vdash x = e : \tau \Rightarrow \Gamma' [x \mapsto \beta], \varphi$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \{ \beta \mid \varphi \} \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma \vdash x: \{ \alpha : \& b \mid \alpha \doteq \&y\}$}
  \LeftLabel{$\text{ASSIGN-STRONG}$}
  \BinaryInfC{$\Gamma \vdash *x = e : \tau \Rightarrow \Gamma' [y \mapsto \beta], \varphi$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \tau \Rightarrow \Gamma'$}
  \AxiomC{$\Gamma \vdash x: \{ \alpha : \& b \mid \alpha \doteq \&y \vee \alpha \doteq \&z \vee \dots\}$}
  \AxiomC{$\Gamma \vdash \tau \preceq \tau_y$}
  \AxiomC{$\Gamma \vdash y : \tau_y$}
  \LeftLabel{$\text{ASSIGN-WEAK}$}
  \QuaternaryInfC{$\Gamma \vdash *x = e : \tau \Rightarrow \Gamma'$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$ (\{a \mapsto \tau_a, \dots\}, \{\alpha \doteq \mu(a), \dots, \varphi_{\alpha}, \dots\}) \preceq \Gamma$}
  \AxiomC{$f : (\{ \alpha \mid \varphi_{\alpha} \} \Rightarrow \{ \alpha' \mid \varphi'_{\alpha} \}, \dots)$}
  \LeftLabel{$\text{FN-CALL}$}
  \BinaryInfC{$\Gamma \vdash f(a, \dots)  \Rightarrow (\mu[a \mapsto \alpha', \dots], \sigma \wedge \varphi'_{\alpha} \wedge \dots)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \tau$}
  \AxiomC{$\Gamma \vdash \tau \preceq \tau'$}
  \LeftLabel{$\text{INTRO-SUB}$}
  \BinaryInfC{$\Gamma \vdash e \texttt{ as } \tau': \tau'$}
\end{prooftree}

\subsection{Sub-Typing Rules: $\Gamma \vdash \tau \preceq \tau'$}

\begin{prooftree}
  \AxiomC{$\sigma \wedge \varphi'[\beta \triangleright \alpha ] \vDash \varphi$}
  \LeftLabel{$\text{$\preceq$-TY}$}
  \UnaryInfC{$\Gamma = (\mu, \sigma) \vdash \{ \alpha \mid \varphi\} \preceq \{ \beta \mid \varphi' \}$}
\end{prooftree}

alternative (should be equivalent):

\begin{prooftree}
  \AxiomC{$\Gamma[f \mapsto \alpha], \varphi \preceq \Gamma[f \mapsto \beta], \varphi'$}
  \AxiomC{$f \text{ fresh}$}
  \LeftLabel{$\text{$\preceq$-TY-ALT}$}
  \BinaryInfC{$\Gamma \vdash \{ \alpha \mid \varphi\} \preceq \{ \beta \mid \varphi' \}$}
\end{prooftree}


\subsection{Sub-Context Rules: $\Gamma \preceq \Gamma'$}


\begin{prooftree}
  \AxiomC{$\sigma'[\mu(\alpha) \triangleright \mu'(\alpha)\ \mid \alpha \in dom(\mu)] \vDash \sigma$}
  \AxiomC{$dom(\mu) \subseteq dom(\mu')$}
  \LeftLabel{$\text{$\preceq$-CTX}$}
  \BinaryInfC{$(\sigma, \mu) \preceq (\sigma', \mu')$}
\end{prooftree}

\subsection{Soundness of the Type System}

As usual, we consider the two properties (see Pierce \cite[p. 95]{pierce_types_2002}) of a type system when assessing the correctness of LiquidRust:

\begin{enumerate}
  \item progress: 
    \todo{need to show for program or term?}
    If $t$ is closed and well-typed, then $t$ is a value or $t \leadsto t'$, where $t'$ is a value.
  \item preservation: If $\Gamma \vdash e : \tau \Rightarrow \Gamma$ and $e \leadsto e'$, then $\Gamma \vdash e' : \tau \Rightarrow \Gamma$
\end{enumerate}

\subsection{Progress}

By induction over the typing derivations $\Gamma \vdash t : \tau \Rightarrow \Gamma'$.

\mtext{LIT} is trivial, \mtext{Var} and \mtext{VAR-REF} cannot occur because $t$ is closed.

\paragraph*{Case LIT} 

\section{Evaluation}

\subsection{Maximum using Path Conditions}



\subsection{Rephrasing builtins in terms of Refinement Types}

\paragraph*{panic}
\paragraph*{assert}

\subsection{Proof of the Gauss Summation Formula}

\section{Related Work}

\end{document}